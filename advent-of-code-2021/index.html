<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0">

    
      
      <meta name="description" content="A blog about SCM, programming, life, and other things." />
      
    

      <title>Dong - Advent of Code 2021</title>

      

      
          <script src="https://cdnjs.cloudflare.com/ajax/libs/slideout/1.0.1/slideout.min.js"></script>
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">

          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/mathtex-script-type.min.js" integrity="sha384-zWYbd0NBwgTsgIdFKVprSfTh1mbMPe5Hz1X3yY4Sd1h/K1cQoUe36OGwAGz/PcDy" crossorigin="anonymous"></script>
              
          <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"
                  onload="renderMathInElement(document.body);"></script>
              
          
      

      
          <link rel="stylesheet" href="https://blog.xiongdong57.top/site.css">
          
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
          
      

      
      
    </head>

    <body>
        <div class="container">

            <div id="mobile-navbar" class="mobile-navbar">
              <div class="mobile-header-logo">
                <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;" class="logo">Dong</a>
              </div>
              <div class="mobile-navbar-icon icon-out">
                <span></span>
                <span></span>
                <span></span>
              </div>
            </div>

            <nav id="mobile-menu" class="mobile-menu slideout-menu slideout-menu-left">
              <ul class="mobile-menu-list">
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;">
                            Home
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;&#x2F;categories">
                            Categories
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;&#x2F;tags">
                            Tags
                        </a>
                    </li>
                
                    <li class="mobile-menu-item">
                        <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;&#x2F;about">
                            About
                        </a>
                    </li>
                
              </ul>
            </nav>

            <header id="header">
                <div class="logo"><a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;">Dong</a></div>
                <nav class="menu">
                    <ul>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;">
                                    Home
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;&#x2F;categories">
                                    Categories
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;&#x2F;tags">
                                    Tags
                                </a>
                            </li>
                        
                            <li>
                                <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;&#x2F;about">
                                    About
                                </a>
                            </li>
                        
                    </ul>
                </nav>
            </header>

            <main>
                <div class="content" id="mobile-panel">
                    


<div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content always-active">
        <nav id="TableOfContents">
            <ul>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#utils-py" class="toc-link">utils.py</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-1-sonar-sweep" class="toc-link">Day 1: Sonar Sweep</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-2-dive" class="toc-link">Day 2: Dive!</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-3-binary-diagnostic" class="toc-link">Day 3: Binary Diagnostic</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-4-giant-squid" class="toc-link">Day 4: Giant Squid</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-5-hydrothermal-venture" class="toc-link">Day 5: Hydrothermal Venture</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-6-lanternfish" class="toc-link">Day 6: Lanternfish</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-7-the-treachery-of-whales" class="toc-link">Day 7: The Treachery of Whales</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-8-seven-segment-search" class="toc-link">Day 8: Seven Segment Search</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-9-smoke-basin" class="toc-link">Day 9: Smoke Basin</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-10-syntax-scoring" class="toc-link">Day 10: Syntax Scoring</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-11-dumbo-octopus" class="toc-link">Day 11: Dumbo Octopus</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-12-passage-pathing" class="toc-link">Day 12: Passage Pathing</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-13-transparent-origami" class="toc-link">Day 13: Transparent Origami</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-14-extended-polymerization" class="toc-link">Day 14: Extended Polymerization</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-15-chiton" class="toc-link">Day 15: Chiton</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-16-packet-decoder" class="toc-link">Day 16: Packet Decoder</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-17-trick-shot" class="toc-link">Day 17: Trick Shot</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-18-snailfish" class="toc-link">Day 18: Snailfish</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-19-beacon-scanner" class="toc-link">Day 19: Beacon Scanner</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-20-trench-map" class="toc-link">Day 20: Trench Map</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-21-dirac-dice" class="toc-link">Day 21: Dirac Dice</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-22-reactor-reboot" class="toc-link">Day 22: Reactor Reboot</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-23-amphipod" class="toc-link">Day 23: Amphipod</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-24-arithmetic-logic-unit" class="toc-link">Day 24: Arithmetic Logic Unit</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#day-25-sea-cucumber" class="toc-link">Day 25: Sea Cucumber</a>
                    
                </li>
                
                <li>
                    <a href="https://blog.xiongdong57.top/advent-of-code-2021/#conclusion" class="toc-link">Conclusion</a>
                    
                </li>
                
            </ul>
        </nav>
    </div>
</div>


<article class="post">
    
    <header class="post__header">
        <h1 class="post__title">
            <a href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;advent-of-code-2021&#x2F;">Advent of Code 2021</a>
        </h1>
        <div class="post__meta">
            <span class="post__time">2021-12-01</span>
            
        </div>
    </header>

    <div class="post-content">
      <p>This year I will do <a href="https://adventofcode.com/">Advent of Code 2021</a>. Considering my programming skills, Python will be used. This article will record simple descriptions of the problems, some of my solution and little notes, which should be updated everyday between December 1st and December 25th. The complete code and data be available on <a href="https://github.com/xiongdong57/AdventofCode2021">GitHub</a>.</p>
<span id="continue-reading"></span><h2 id="utils-py">utils.py</h2>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>: int, </span><span style="color:#bf616a;">parser</span><span>=str, </span><span style="color:#bf616a;">sep</span><span>=&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;):
</span><span>    </span><span style="color:#b48ead;">with </span><span style="color:#96b5b4;">open</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;</span><span style="color:#a3be8c;">input/day</span><span>{day</span><span style="color:#d08770;">:02d</span><span>}</span><span style="color:#a3be8c;">.txt</span><span>&#39;) </span><span style="color:#b48ead;">as </span><span>f:
</span><span>        </span><span style="color:#b48ead;">return </span><span>[</span><span style="color:#bf616a;">parser</span><span>(line) </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>f.</span><span style="color:#bf616a;">read</span><span>().</span><span style="color:#bf616a;">split</span><span>(sep)]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">convert_to_int</span><span>(</span><span style="color:#bf616a;">data</span><span>: List):
</span><span>    </span><span style="color:#b48ead;">return </span><span>[</span><span style="color:#bf616a;">int</span><span>(elem) </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>data]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">print_map</span><span>(</span><span style="color:#bf616a;">system</span><span>, </span><span style="color:#bf616a;">fillin</span><span>=&#39;</span><span style="color:#a3be8c;">.</span><span>&#39;):
</span><span>    </span><span style="color:#65737e;"># print the {(x, y): val} map
</span><span>    x_max = </span><span style="color:#96b5b4;">max</span><span>(system, </span><span style="color:#bf616a;">key</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x[</span><span style="color:#d08770;">0</span><span>])[</span><span style="color:#d08770;">0</span><span>]
</span><span>    x_min = </span><span style="color:#96b5b4;">min</span><span>(system, </span><span style="color:#bf616a;">key</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x[</span><span style="color:#d08770;">0</span><span>])[</span><span style="color:#d08770;">0</span><span>]
</span><span>    y_max = </span><span style="color:#96b5b4;">max</span><span>(system, </span><span style="color:#bf616a;">key</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x[</span><span style="color:#d08770;">1</span><span>])[</span><span style="color:#d08770;">1</span><span>]
</span><span>    y_min = </span><span style="color:#96b5b4;">min</span><span>(system, </span><span style="color:#bf616a;">key</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x[</span><span style="color:#d08770;">1</span><span>])[</span><span style="color:#d08770;">1</span><span>]
</span><span>    </span><span style="color:#b48ead;">for </span><span>dy </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(y_min, y_max + </span><span style="color:#d08770;">1</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>dx </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(x_min, x_max + </span><span style="color:#d08770;">1</span><span>):
</span><span>            </span><span style="color:#96b5b4;">print</span><span>(system.</span><span style="color:#bf616a;">get</span><span>((dx, dy), fillin), </span><span style="color:#bf616a;">end</span><span>=&#39;&#39;)
</span><span>        </span><span style="color:#96b5b4;">print</span><span>()
</span><span>    </span><span style="color:#96b5b4;">print</span><span>()
</span></code></pre>
<h2 id="day-1-sonar-sweep"><a href="https://adventofcode.com/2021/day/1">Day 1: Sonar Sweep</a></h2>
<p>You had the following report:<br />
199<br />
200<br />
208<br />
210<br />
200<br />
207<br />
240<br />
269<br />
260<br />
263</p>
<ol>
<li>How many measurements are larger than the previous measurement?</li>
<li>Consider sums of a three-measurement sliding window. How many sums are larger than the previous sum?</li>
</ol>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day01_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    increase_count = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#96b5b4;">len</span><span>(data)):
</span><span>        </span><span style="color:#b48ead;">if </span><span>data[i] &gt; data[i - </span><span style="color:#d08770;">1</span><span>]:
</span><span>            increase_count += </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">return </span><span>increase_count
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day01_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    data_with_3_window = [</span><span style="color:#96b5b4;">sum</span><span>(data[i:i+</span><span style="color:#d08770;">3</span><span>]) </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data) - </span><span style="color:#d08770;">2</span><span>)]
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">day01_1</span><span>(data_with_3_window)
</span></code></pre>
<h2 id="day-2-dive"><a href="https://adventofcode.com/2021/day/2">Day 2: Dive!</a></h2>
<p>Input be like:<br />
forward 5<br />
down 5<br />
forward 8<br />
up 3<br />
down 8<br />
forward 2</p>
<p>part1 with rule:</p>
<ul>
<li>forward X increases the horizontal position by X units.</li>
<li>down X increases the depth by X units.</li>
<li>up X decreases the depth by X units.</li>
</ul>
<p>part2 with rule:</p>
<ul>
<li>down X increases your aim by X units.</li>
<li>up X decreases your aim by X units.</li>
<li>forward X does two things:
<ul>
<li>It increases your horizontal position by X units.</li>
<li>It increases your depth by your aim multiplied by X.</li>
</ul>
</li>
</ul>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day02_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    horizon = </span><span style="color:#d08770;">0
</span><span>    depth = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>action, num </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        </span><span style="color:#b48ead;">if </span><span>action == &#39;</span><span style="color:#a3be8c;">forward</span><span>&#39;:
</span><span>            horizon += </span><span style="color:#bf616a;">int</span><span>(num)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>action == &#39;</span><span style="color:#a3be8c;">down</span><span>&#39;:
</span><span>            depth += </span><span style="color:#bf616a;">int</span><span>(num)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>action == &#39;</span><span style="color:#a3be8c;">up</span><span>&#39;:
</span><span>            depth -= </span><span style="color:#bf616a;">int</span><span>(num)
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            </span><span style="color:#b48ead;">raise </span><span style="color:#bf616a;">ValueError</span><span>(&#39;</span><span style="color:#a3be8c;">Invalid action: </span><span style="color:#d08770;">{}</span><span>&#39;.</span><span style="color:#bf616a;">format</span><span>(action))
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">abs</span><span>(horizon) * </span><span style="color:#96b5b4;">abs</span><span>(depth)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day02_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    aim = </span><span style="color:#d08770;">0
</span><span>    horizon = </span><span style="color:#d08770;">0
</span><span>    depth = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>action, num </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        </span><span style="color:#b48ead;">if </span><span>action == &#39;</span><span style="color:#a3be8c;">down</span><span>&#39;:
</span><span>            aim += </span><span style="color:#bf616a;">int</span><span>(num)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>action == &#39;</span><span style="color:#a3be8c;">up</span><span>&#39;:
</span><span>            aim -= </span><span style="color:#bf616a;">int</span><span>(num)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>action == &#39;</span><span style="color:#a3be8c;">forward</span><span>&#39;:
</span><span>            horizon += </span><span style="color:#bf616a;">int</span><span>(num)
</span><span>            depth += aim * </span><span style="color:#bf616a;">int</span><span>(num)
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            </span><span style="color:#b48ead;">raise </span><span style="color:#bf616a;">ValueError</span><span>(&#39;</span><span style="color:#a3be8c;">Invalid action: </span><span style="color:#d08770;">{}</span><span>&#39;.</span><span style="color:#bf616a;">format</span><span>(action))
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">abs</span><span>(horizon) * </span><span style="color:#96b5b4;">abs</span><span>(depth)
</span><span>
</span><span>data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">2</span><span>, </span><span style="color:#bf616a;">parser</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x.</span><span style="color:#bf616a;">split</span><span>(&#39; &#39;))
</span></code></pre>
<h2 id="day-3-binary-diagnostic"><a href="https://adventofcode.com/2021/day/3">Day 3: Binary Diagnostic</a></h2>
<p>Input be like:
00100<br />
11110<br />
10110<br />
10111<br />
10101<br />
01111<br />
00111<br />
11100<br />
10000<br />
11001<br />
00010<br />
01010</p>
<p>part1 with rule:</p>
<ul>
<li>gamma rate can be determined by finding the most common bit in the corresponding position of all numbers in the diagnostic report</li>
<li>epsilon rate is calculated in a similar way; rather than use the most common bit, the least common bit from each position is used</li>
<li>What is the power consumption of the submarine(gamma rate multiplied by epsilon rate)</li>
</ul>
<p>part2 with rule:</p>
<ul>
<li>Keep only numbers selected by the bit criteria for the type of rating value for which you are searching. Discard numbers which do not match the bit criteria.</li>
<li>If you only have one number left, stop; this is the rating value for which you are searching. Otherwise, repeat the process, considering the next bit to the right.</li>
</ul>
<p>The bit criteria depends on which type of rating value you want to find:</p>
<ul>
<li>To find oxygen generator rating, determine the most common value (0 or 1) in the current bit position, and keep only numbers with that bit in that position. If 0 and 1 are equally common, keep values with a 1 in the position being considered.</li>
<li>To find CO2 scrubber rating, determine the least common value (0 or 1) in the current bit position, and keep only numbers with that bit in that position. If 0 and 1 are equally common, keep values with a 0 in the position being considered.</li>
</ul>
<p>What is the life support rating of the submarine(oxygen generator rating multiplied by CO2 scrubber rating)</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">common_bit</span><span>(</span><span style="color:#bf616a;">lst</span><span>, </span><span style="color:#bf616a;">descending</span><span>=</span><span style="color:#d08770;">False</span><span>):
</span><span>    one_count = lst.</span><span style="color:#bf616a;">count</span><span>(&#39;</span><span style="color:#a3be8c;">1</span><span>&#39;)
</span><span>    zero_count = lst.</span><span style="color:#bf616a;">count</span><span>(&#39;</span><span style="color:#a3be8c;">0</span><span>&#39;)
</span><span>    </span><span style="color:#b48ead;">if </span><span>descending:
</span><span>        </span><span style="color:#b48ead;">return </span><span>&#39;</span><span style="color:#a3be8c;">1</span><span>&#39; </span><span style="color:#b48ead;">if </span><span>one_count &gt;= zero_count </span><span style="color:#b48ead;">else </span><span>&#39;</span><span style="color:#a3be8c;">0</span><span>&#39;
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span>&#39;</span><span style="color:#a3be8c;">0</span><span>&#39; </span><span style="color:#b48ead;">if </span><span>one_count &gt;= zero_count </span><span style="color:#b48ead;">else </span><span>&#39;</span><span style="color:#a3be8c;">1</span><span>&#39;
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day03_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    gamma_rate_str = &#39;&#39;
</span><span>    epsilon_rate_str = &#39;&#39;
</span><span>    </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data[</span><span style="color:#d08770;">0</span><span>])):
</span><span>        bits = [elem[i] </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>data]
</span><span>        gamma_rate_str += </span><span style="color:#bf616a;">common_bit</span><span>(bits, </span><span style="color:#bf616a;">descending</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span><span>        epsilon_rate_str += </span><span style="color:#bf616a;">common_bit</span><span>(bits, </span><span style="color:#bf616a;">descending</span><span>=</span><span style="color:#d08770;">False</span><span>)
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">int</span><span>(gamma_rate_str, </span><span style="color:#d08770;">2</span><span>) * </span><span style="color:#bf616a;">int</span><span>(epsilon_rate_str, </span><span style="color:#d08770;">2</span><span>)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_bit_criteria</span><span>(</span><span style="color:#bf616a;">data</span><span>, </span><span style="color:#bf616a;">descending</span><span>=</span><span style="color:#d08770;">True</span><span>):
</span><span>    filtered_data = data[:]
</span><span>    </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data[</span><span style="color:#d08770;">0</span><span>])):
</span><span>        bits = [elem[i] </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>filtered_data]
</span><span>        filter_bit = </span><span style="color:#bf616a;">common_bit</span><span>(bits, </span><span style="color:#bf616a;">descending</span><span>=descending)
</span><span>        filtered_data = [
</span><span>            elem </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>filtered_data </span><span style="color:#b48ead;">if </span><span>elem[i] == filter_bit]
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">len</span><span>(filtered_data) == </span><span style="color:#d08770;">1</span><span>:
</span><span>            </span><span style="color:#b48ead;">return </span><span>filtered_data[</span><span style="color:#d08770;">0</span><span>]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day03_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    oxygen_generator_rate_str = </span><span style="color:#bf616a;">gen_bit_criteria</span><span>(data, </span><span style="color:#bf616a;">descending</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span><span>    CO2_scrubber_rate_str = </span><span style="color:#bf616a;">gen_bit_criteria</span><span>(data, </span><span style="color:#bf616a;">descending</span><span>=</span><span style="color:#d08770;">False</span><span>)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">int</span><span>(oxygen_generator_rate_str, </span><span style="color:#d08770;">2</span><span>) * </span><span style="color:#bf616a;">int</span><span>(CO2_scrubber_rate_str, </span><span style="color:#d08770;">2</span><span>)
</span><span>
</span><span>data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">3</span><span>, </span><span style="color:#bf616a;">parser</span><span>=str)
</span></code></pre>
<h2 id="day-4-giant-squid"><a href="https://adventofcode.com/2021/day/4">Day 4: Giant Squid</a></h2>
<p>Bingo is played on a set of boards each consisting of a 5x5 grid of numbers. Numbers are chosen at random, and the chosen number is marked on all boards on which it appears. (Numbers may not appear on all boards.) If all numbers in any row or any column of a board are marked, that board wins.</p>
<p>Input be like:<br />
7,4,9,5,11,17,23,2,0,14,21,24,10,16,13,6,15,25,12,22,18,20,8,19,3,26,1</p>
<p>22 13 17 11  0<br />
8  2 23  4 24<br />
21  9 14 16  7<br />
6 10  3 18  5<br />
1 12 20 15 19</p>
<p>3 15  0  2 22<br />
9 18 13 17  5<br />
19  8  7 25 23<br />
20 11 10 24  4<br />
14 21 16 12  6</p>
<p>14 21 17 24  4<br />
10 16 15  9 19<br />
18  8 23 26 20<br />
22 11 13  6  5<br />
2  0 12  3  7</p>
<p>score is the sum of all unmarked numbers multiply that sum by the number that was just called when the board won.</p>
<p>part1:  What will your final score be if you choose that board
part2:  figure out which board will win last and choose that one, figure out which board will win last and choose that one</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">convert_to_int</span><span>(</span><span style="color:#bf616a;">data</span><span>: List):
</span><span>    </span><span style="color:#b48ead;">return </span><span>[</span><span style="color:#bf616a;">int</span><span>(elem) </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>data]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">parse_input</span><span>():
</span><span>    data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">4</span><span>, </span><span style="color:#bf616a;">parser</span><span>=str.splitlines, </span><span style="color:#bf616a;">sep</span><span>=&#39;</span><span style="color:#96b5b4;">\n\n</span><span>&#39;)
</span><span>    nums = </span><span style="color:#bf616a;">convert_to_int</span><span>(data[</span><span style="color:#d08770;">0</span><span>][</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;))
</span><span>    boards = [[</span><span style="color:#bf616a;">convert_to_int</span><span>(line.</span><span style="color:#bf616a;">split</span><span>()) </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>board]
</span><span>              </span><span style="color:#b48ead;">for </span><span>board </span><span style="color:#b48ead;">in </span><span>data[</span><span style="color:#d08770;">1</span><span>:]]
</span><span>    </span><span style="color:#b48ead;">return </span><span>nums, boards
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">board_marks_valid</span><span>(</span><span style="color:#bf616a;">board</span><span>: List[List], </span><span style="color:#bf616a;">marked_nums</span><span>: set):
</span><span>    cols = [</span><span style="color:#bf616a;">set</span><span>([row[i] </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span>board])
</span><span>            </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(board[</span><span style="color:#d08770;">0</span><span>]))]
</span><span>    rows = [</span><span style="color:#bf616a;">set</span><span>(row) </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span>board]
</span><span>    lines = cols + rows
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">any</span><span>(line.</span><span style="color:#bf616a;">issubset</span><span>(marked_nums) </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>lines)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day04_1</span><span>(</span><span style="color:#bf616a;">nums</span><span>, </span><span style="color:#bf616a;">boards</span><span>):
</span><span>    </span><span style="color:#b48ead;">for </span><span>i, num </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(nums):
</span><span>        </span><span style="color:#b48ead;">for </span><span>board </span><span style="color:#b48ead;">in </span><span>boards:
</span><span>            marked_nums = </span><span style="color:#bf616a;">set</span><span>(nums[:i+</span><span style="color:#d08770;">1</span><span>])
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">board_marks_valid</span><span>(board, marked_nums):
</span><span>                all_unmark_nums_sum = </span><span style="color:#96b5b4;">sum</span><span>([elem
</span><span>                                           </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span>board
</span><span>                                           </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>row
</span><span>                                           </span><span style="color:#b48ead;">if </span><span>elem not in marked_nums])
</span><span>                </span><span style="color:#b48ead;">return </span><span>num * all_unmark_nums_sum
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day04_2</span><span>(</span><span style="color:#bf616a;">nums</span><span>, </span><span style="color:#bf616a;">boards</span><span>):
</span><span>    remain_boards = boards[:]
</span><span>    </span><span style="color:#b48ead;">for </span><span>i, num </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(nums):
</span><span>        marked_nums = </span><span style="color:#bf616a;">set</span><span>(nums[:i+</span><span style="color:#d08770;">1</span><span>])
</span><span>        remain_boards = [board
</span><span>                         </span><span style="color:#b48ead;">for </span><span>board </span><span style="color:#b48ead;">in </span><span>remain_boards
</span><span>                         </span><span style="color:#b48ead;">if </span><span>not </span><span style="color:#bf616a;">board_marks_valid</span><span>(board, marked_nums)]
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">len</span><span>(remain_boards) == </span><span style="color:#d08770;">1</span><span>:
</span><span>            last_board = remain_boards[</span><span style="color:#d08770;">0</span><span>]
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">len</span><span>(remain_boards) == </span><span style="color:#d08770;">0</span><span>:
</span><span>            all_unmark_nums_sum = </span><span style="color:#96b5b4;">sum</span><span>([elem
</span><span>                                       </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span>last_board
</span><span>                                       </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>row
</span><span>                                       </span><span style="color:#b48ead;">if </span><span>elem not in marked_nums])
</span><span>            </span><span style="color:#b48ead;">return </span><span>num * all_unmark_nums_sum
</span></code></pre>
<p>If this puzzle is more complex, maybe numpy is a good way to go.</p>
<h2 id="day-5-hydrothermal-venture"><a href="https://adventofcode.com/2021/day/5">Day 5: Hydrothermal Venture</a></h2>
<p>For lines:<br />
0,9 -&gt; 5,9<br />
8,0 -&gt; 0,8<br />
9,4 -&gt; 3,4<br />
2,2 -&gt; 2,1<br />
7,0 -&gt; 7,4<br />
6,4 -&gt; 2,0<br />
0,9 -&gt; 2,9<br />
3,4 -&gt; 1,4<br />
0,0 -&gt; 8,8<br />
5,5 -&gt; 8,2</p>
<p>you need to determine the number of points where at least two lines overlap.</p>
<p>part1: Consider only horizontal and vertical lines. At how many points do at least two lines overlap?</p>
<p>part2: Because of the limits of the hydrothermal vent mapping system, the lines in your list will only ever be horizontal, vertical, or a diagonal line at exactly 45 degrees.Consider all of the lines. How many points do at least two lines overlap?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_line_points</span><span>(</span><span style="color:#bf616a;">x1</span><span>, </span><span style="color:#bf616a;">y1</span><span>, </span><span style="color:#bf616a;">x2</span><span>, </span><span style="color:#bf616a;">y2</span><span>, </span><span style="color:#bf616a;">diagonal_line</span><span>=</span><span style="color:#d08770;">False</span><span>):
</span><span>    points = []
</span><span>    x_min = </span><span style="color:#96b5b4;">min</span><span>(x1, x2)
</span><span>    x_max = </span><span style="color:#96b5b4;">max</span><span>(x1, x2)
</span><span>    y_min = </span><span style="color:#96b5b4;">min</span><span>(y1, y2)
</span><span>    y_max = </span><span style="color:#96b5b4;">max</span><span>(y1, y2)
</span><span>    </span><span style="color:#b48ead;">if </span><span>x1 == x2:
</span><span>        </span><span style="color:#b48ead;">for </span><span>y </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(y_min, y_max + </span><span style="color:#d08770;">1</span><span>):
</span><span>            points.</span><span style="color:#bf616a;">append</span><span>((x1, y))
</span><span>    </span><span style="color:#b48ead;">elif </span><span>y1 == y2:
</span><span>        </span><span style="color:#b48ead;">for </span><span>x </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(x_min, x_max + </span><span style="color:#d08770;">1</span><span>):
</span><span>            points.</span><span style="color:#bf616a;">append</span><span>((x, y1))
</span><span>    </span><span style="color:#b48ead;">elif </span><span>diagonal_line:
</span><span>        ascending = ((x1 == x_min and y1 == y_min) or
</span><span>                     (x2 == x_min and y2 == y_min))
</span><span>        </span><span style="color:#b48ead;">for </span><span>x </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(x_min, x_max + </span><span style="color:#d08770;">1</span><span>):
</span><span>            </span><span style="color:#b48ead;">if </span><span>ascending:
</span><span>                points.</span><span style="color:#bf616a;">append</span><span>((x, y_min + (x - x_min)))
</span><span>            </span><span style="color:#b48ead;">else</span><span>:
</span><span>                points.</span><span style="color:#bf616a;">append</span><span>((x, y_max - (x - x_min)))
</span><span>    </span><span style="color:#b48ead;">return </span><span>points
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">solve</span><span>(</span><span style="color:#bf616a;">data</span><span>, </span><span style="color:#bf616a;">diagnoal_line</span><span>):
</span><span>    picture = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        x1, y1, x2, y2 = [</span><span style="color:#bf616a;">int</span><span>(elem) </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>line]
</span><span>        </span><span style="color:#b48ead;">for </span><span>point </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">gen_line_points</span><span>(x1, y1, x2, y2,
</span><span>                                     </span><span style="color:#bf616a;">diagonal_line</span><span>=diagnoal_line):
</span><span>            picture[point] += </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">sum</span><span>(</span><span style="color:#d08770;">1 </span><span style="color:#b48ead;">for </span><span>value </span><span style="color:#b48ead;">in </span><span>picture.</span><span style="color:#bf616a;">values</span><span>() </span><span style="color:#b48ead;">if </span><span>value &gt; </span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day05_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">solve</span><span>(data, </span><span style="color:#bf616a;">diagnoal_line</span><span>=</span><span style="color:#d08770;">False</span><span>)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day05_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">solve</span><span>(data, </span><span style="color:#bf616a;">diagnoal_line</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span><span>
</span><span>
</span><span>data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">5</span><span>,
</span><span>                  </span><span style="color:#bf616a;">parser</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: re.</span><span style="color:#bf616a;">findall</span><span>(
</span><span>                    </span><span style="color:#b48ead;">r</span><span>&#39;</span><span style="color:#a3be8c;">(</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">),(</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">) -&gt; (</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">),(</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">)</span><span>&#39;, x)[</span><span style="color:#d08770;">0</span><span>])
</span></code></pre>
<p>Data structure is really a key thing to solve the problem with simple and clean solution.</p>
<h2 id="day-6-lanternfish"><a href="https://adventofcode.com/2021/day/6">Day 6: Lanternfish</a></h2>
<p>Each lanternfish creates a new lanternfish once every 7 days and a new lanternfish need slightly longer before it's capable of producing more lanternfish: two more days for its first cycle. We model each fish as a single number that represents the number of days until it creates a new lanternfish.</p>
<p>Input be like:<br />
3,4,3,1,2</p>
<p>part1: How many lanternfish would there be after 80 days?<br />
part2: ow many lanternfish would there be after 256 days</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">simulate</span><span>(</span><span style="color:#bf616a;">states</span><span>: List):
</span><span>    new_gen_state = states.</span><span style="color:#bf616a;">count</span><span>(</span><span style="color:#d08770;">0</span><span>) * [</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#d08770;">8</span><span>]
</span><span>    updated_states = [elem - </span><span style="color:#d08770;">1 </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>states </span><span style="color:#b48ead;">if </span><span>elem != </span><span style="color:#d08770;">0</span><span>]
</span><span>    </span><span style="color:#b48ead;">return </span><span>updated_states + new_gen_state
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">simulate_2</span><span>(</span><span style="color:#bf616a;">state</span><span>: defaultdict):
</span><span>    new_state = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    </span><span style="color:#b48ead;">for </span><span>key, value </span><span style="color:#b48ead;">in </span><span>state.</span><span style="color:#bf616a;">items</span><span>():
</span><span>        </span><span style="color:#b48ead;">if </span><span>key == </span><span style="color:#d08770;">0</span><span>:
</span><span>            new_state[</span><span style="color:#d08770;">6</span><span>] += value
</span><span>            new_state[</span><span style="color:#d08770;">8</span><span>] += value
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            new_state[key - </span><span style="color:#d08770;">1</span><span>] += value
</span><span>    </span><span style="color:#b48ead;">return </span><span>new_state
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day06_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    state = data[:]
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">_ </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">80</span><span>):
</span><span>        state = </span><span style="color:#bf616a;">simulate</span><span>(state)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(state)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day06_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    state = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        </span><span style="color:#b48ead;">if </span><span>elem not in state.</span><span style="color:#bf616a;">keys</span><span>():
</span><span>            state[elem] = data.</span><span style="color:#bf616a;">count</span><span>(elem)
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">_ </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">256</span><span>):
</span><span>        state = </span><span style="color:#bf616a;">simulate_2</span><span>(state)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">sum</span><span>(state.</span><span style="color:#bf616a;">values</span><span>())
</span><span>
</span><span>data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">6</span><span>, </span><span style="color:#bf616a;">parser</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;))[</span><span style="color:#d08770;">0</span><span>]
</span><span>data = </span><span style="color:#bf616a;">convert_to_int</span><span>(data)
</span></code></pre>
<p>Again, data structure is the key to the right solution.</p>
<h2 id="day-7-the-treachery-of-whales"><a href="https://adventofcode.com/2021/day/7">Day 7: The Treachery of Whales</a></h2>
<p>List of the horizontal position of each crab:<br />
16,1,2,0,4,2,7,1,2,14</p>
<p>part1 with rule:<br />
Each change of 1 step in horizontal position of a single crab costs 1 fuel. Determine the horizontal position that the crabs can align to using the least fuel possible.</p>
<p>How much fuel must they spend to align to that position?</p>
<p>part2 with rule:<br />
ach change of 1 step in horizontal position costs 1 more unit of fuel than the last: the first step costs 1, the second step costs 2, the third step costs 3, and so on</p>
<p>How much fuel must they spend to align to that position?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">fuel_cost</span><span>(</span><span style="color:#bf616a;">seq</span><span>, </span><span style="color:#bf616a;">pos</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">sum</span><span>(</span><span style="color:#96b5b4;">abs</span><span>(elem - pos) </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>seq)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day07_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    pos_min = </span><span style="color:#96b5b4;">min</span><span>(data)
</span><span>    pos_max = </span><span style="color:#96b5b4;">max</span><span>(data)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">min</span><span>(</span><span style="color:#bf616a;">fuel_cost</span><span>(data, pos) </span><span style="color:#b48ead;">for </span><span>pos </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(pos_min, pos_max + </span><span style="color:#d08770;">1</span><span>))
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">fuel_cost_v2</span><span>(</span><span style="color:#bf616a;">seq</span><span>, </span><span style="color:#bf616a;">pos</span><span>):
</span><span>    </span><span style="color:#65737e;"># basic math: 1 + 2 + ... + n = n(n+1)/2
</span><span>    fuels = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>seq:
</span><span>        distance = </span><span style="color:#96b5b4;">abs</span><span>(elem - pos)
</span><span>        fuels += </span><span style="color:#bf616a;">int</span><span>(distance * (distance + </span><span style="color:#d08770;">1</span><span>) / </span><span style="color:#d08770;">2</span><span>)
</span><span>    </span><span style="color:#b48ead;">return </span><span>fuels
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day07_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    pos_min = </span><span style="color:#96b5b4;">min</span><span>(data)
</span><span>    pos_max = </span><span style="color:#96b5b4;">max</span><span>(data)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">min</span><span>(</span><span style="color:#bf616a;">fuel_cost_v2</span><span>(data, pos) </span><span style="color:#b48ead;">for </span><span>pos </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(pos_min, pos_max + </span><span style="color:#d08770;">1</span><span>))
</span><span>
</span><span>data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">7</span><span>, </span><span style="color:#bf616a;">parser</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;))[</span><span style="color:#d08770;">0</span><span>]
</span><span>data = </span><span style="color:#bf616a;">convert_to_int</span><span>(data)
</span></code></pre>
<h2 id="day-8-seven-segment-search"><a href="https://adventofcode.com/2021/day/8">Day 8: Seven Segment Search</a></h2>
<p>Input be like:<br />
acedgfb cdfbe gcdfa fbcad dab cefabd cdfgeb eafb cagedb ab | cdfeb fcadb cdfeb cdbaf</p>
<p>before | is the 0-9 numbers, after | can be translate to digits.</p>
<p>Code be like:</p>
<pre data-lang="text" style="background-color:#2b303b;color:#c0c5ce;" class="language-text "><code class="language-text" data-lang="text"><span>  0:      1:      2:      3:      4:  
</span><span> aaaa    ....    aaaa    aaaa    ....  
</span><span>b    c  .    c  .    c  .    c  b    c  
</span><span>b    c  .    c  .    c  .    c  b    c  
</span><span> ....    ....    dddd    dddd    dddd  
</span><span>e    f  .    f  e    .  .    f  .    f  
</span><span>e    f  .    f  e    .  .    f  .    f  
</span><span> gggg    ....    gggg    gggg    ....  
</span><span>  
</span><span>  5:      6:      7:      8:      9:  
</span><span> aaaa    aaaa    aaaa    aaaa    aaaa  
</span><span>b    .  b    .  .    c  b    c  b    c  
</span><span>b    .  b    .  .    c  b    c  b    c  
</span><span> dddd    dddd    ....    dddd    dddd  
</span><span>.    f  e    f  .    f  e    f  .    f  
</span><span>.    f  e    f  .    f  e    f  .    f  
</span><span> gggg    gggg    ....    gggg    gggg  
</span></code></pre>
<p>part1: In the output values, how many times do digits 1, 4, 7, or 8 appear?(hints: 1, 4, 7, 8 use a unique number of segments)</p>
<p>part2: For each entry, determine all of the wire/segment connections and decode the four-digit output values. What do you get if you add up all of the output values?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_data</span><span>():
</span><span>    patterns = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">8</span><span>, </span><span style="color:#bf616a;">parser</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;"> | </span><span>&#39;)[</span><span style="color:#d08770;">0</span><span>])
</span><span>    digits = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">8</span><span>, </span><span style="color:#bf616a;">parser</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;"> | </span><span>&#39;)[</span><span style="color:#d08770;">1</span><span>])
</span><span>    patterns = [pattern.</span><span style="color:#bf616a;">split</span><span>() </span><span style="color:#b48ead;">for </span><span>pattern </span><span style="color:#b48ead;">in </span><span>patterns]
</span><span>    digits = [digit.</span><span style="color:#bf616a;">split</span><span>() </span><span style="color:#b48ead;">for </span><span>digit </span><span style="color:#b48ead;">in </span><span>digits]
</span><span>    </span><span style="color:#b48ead;">return </span><span>patterns, digits
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day08_1</span><span>(</span><span style="color:#bf616a;">patterns</span><span>, </span><span style="color:#bf616a;">digits</span><span>):
</span><span>    segments_map = {
</span><span>        </span><span style="color:#d08770;">1</span><span>: </span><span style="color:#d08770;">2</span><span>,
</span><span>        </span><span style="color:#d08770;">4</span><span>: </span><span style="color:#d08770;">4</span><span>,
</span><span>        </span><span style="color:#d08770;">7</span><span>: </span><span style="color:#d08770;">3</span><span>,
</span><span>        </span><span style="color:#d08770;">8</span><span>: </span><span style="color:#d08770;">7
</span><span>    }
</span><span>    only_digits_counts = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>digits:
</span><span>        </span><span style="color:#b48ead;">for </span><span>digit </span><span style="color:#b48ead;">in </span><span>line:
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">len</span><span>(digit) in segments_map.</span><span style="color:#bf616a;">values</span><span>():
</span><span>                only_digits_counts += </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">return </span><span>only_digits_counts
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">translate_to_chars</span><span>(</span><span style="color:#bf616a;">translator</span><span>, </span><span style="color:#bf616a;">chars</span><span>: str):
</span><span>    traslate_map = str.</span><span style="color:#bf616a;">maketrans</span><span>(&#39;&#39;.</span><span style="color:#bf616a;">join</span><span>(translator), &#39;</span><span style="color:#a3be8c;">abcdefg</span><span>&#39;)
</span><span>    </span><span style="color:#b48ead;">return </span><span>chars.</span><span style="color:#bf616a;">translate</span><span>(traslate_map)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">translate_to_num</span><span>(</span><span style="color:#bf616a;">chars</span><span>: str):
</span><span>    char_to_num = {
</span><span>        &#39;</span><span style="color:#a3be8c;">abcefg</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">0</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">cf</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">1</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">acdeg</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">2</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">acdfg</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">3</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">bcdf</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">4</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">abdfg</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">5</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">abdefg</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">6</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">acf</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">7</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">abcdefg</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">8</span><span>&#39;,
</span><span>        &#39;</span><span style="color:#a3be8c;">abcdfg</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">9</span><span>&#39;
</span><span>    }
</span><span>    key = &#39;&#39;.</span><span style="color:#bf616a;">join</span><span>(</span><span style="color:#96b5b4;">sorted</span><span>(chars))
</span><span>    </span><span style="color:#b48ead;">return </span><span>char_to_num.</span><span style="color:#bf616a;">get</span><span>(key, &#39;&#39;)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">origin_chars_to_num</span><span>(</span><span style="color:#bf616a;">origin_chars</span><span>, </span><span style="color:#bf616a;">translator</span><span>):
</span><span>    chars = </span><span style="color:#bf616a;">translate_to_chars</span><span>(translator, origin_chars)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">translate_to_num</span><span>(chars)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">valid</span><span>(</span><span style="color:#bf616a;">pattern</span><span>, </span><span style="color:#bf616a;">translator</span><span>):
</span><span>    nums = [</span><span style="color:#bf616a;">origin_chars_to_num</span><span>(ch, translator) </span><span style="color:#b48ead;">for </span><span>ch </span><span style="color:#b48ead;">in </span><span>pattern]
</span><span>    mark = &#39;&#39;.</span><span style="color:#bf616a;">join</span><span>(</span><span style="color:#96b5b4;">sorted</span><span>(nums))
</span><span>    </span><span style="color:#b48ead;">return </span><span>mark == &#39;</span><span style="color:#a3be8c;">0123456789</span><span>&#39;
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">solve_tranlator</span><span>(</span><span style="color:#bf616a;">pattern</span><span>):
</span><span>    </span><span style="color:#65737e;"># brute force, may be some clever dfs also can solve this
</span><span>    </span><span style="color:#b48ead;">for </span><span>translator </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">permutations</span><span>(&#39;</span><span style="color:#a3be8c;">abcdefg</span><span>&#39;, </span><span style="color:#d08770;">7</span><span>):
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">valid</span><span>(pattern, translator):
</span><span>            </span><span style="color:#b48ead;">return </span><span>translator
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day08_2</span><span>(</span><span style="color:#bf616a;">patterns</span><span>, </span><span style="color:#bf616a;">digits</span><span>):
</span><span>    all_sum = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>pattern, digit_nums </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">zip</span><span>(patterns, digits):
</span><span>        translator = </span><span style="color:#bf616a;">solve_tranlator</span><span>(pattern)
</span><span>        num = &#39;&#39;
</span><span>        </span><span style="color:#b48ead;">for </span><span>digit </span><span style="color:#b48ead;">in </span><span>digit_nums:
</span><span>            num += </span><span style="color:#bf616a;">origin_chars_to_num</span><span>(digit, translator)
</span><span>        all_sum += </span><span style="color:#bf616a;">int</span><span>(num)
</span><span>    </span><span style="color:#b48ead;">return </span><span>all_sum
</span><span>
</span><span>
</span><span>patterns, digits = </span><span style="color:#bf616a;">gen_data</span><span>()
</span></code></pre>
<p>Part1 is easy, after careful understanding the matiral. Part2 first comes to DFS, then I find it's hard to mapping the iterate rule. Then when broswing reddit, someone mentioned brute force. May be  I should calc how many possible combinations and the result number is quit small(less than 10000). Finally, using brute force to solve it.</p>
<h2 id="day-9-smoke-basin"><a href="https://adventofcode.com/2021/day/9">Day 9: Smoke Basin</a></h2>
<p>consider the following heightmap:<br />
2199943210<br />
3987894921<br />
9856789892<br />
8767896789<br />
9899965678</p>
<p>Your first goal is to find the low points - the locations that are lower than any of its adjacent locations.Most locations have four adjacent locations (up, down, left, and right). The risk level of a low point is 1 plus its height.</p>
<p>Part1: What is the sum of the risk levels of all low points on your heightmap?</p>
<p>A basin is all locations that eventually flow downward to a single low point. Therefore, every low point has a basin, although some basins are very small. Locations of height 9 do not count as being in any basin, and all other locations will always be part of exactly one basin.</p>
<p>The size of a basin is the number of locations within the basin, including the low point.</p>
<p>Part2: What do you get if you multiply together the sizes of the three largest basins?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">is_lowest_adjacent</span><span>(</span><span style="color:#bf616a;">height_map</span><span>, </span><span style="color:#bf616a;">loc</span><span>):
</span><span>    x, y = loc
</span><span>    height = height_map[loc]
</span><span>    </span><span style="color:#65737e;"># only consider up, down, left and right
</span><span>    directions = [(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>), (</span><span style="color:#d08770;">0</span><span>, -</span><span style="color:#d08770;">1</span><span>), (</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>), (-</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>)]
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">all</span><span>(height_map.</span><span style="color:#bf616a;">get</span><span>((x+dx, y+dy), </span><span style="color:#d08770;">9</span><span>) &gt; height
</span><span>               </span><span style="color:#b48ead;">for </span><span>dx, dy </span><span style="color:#b48ead;">in </span><span>directions)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">make_map</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    height_map = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data)):
</span><span>        </span><span style="color:#b48ead;">for </span><span>col </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data[row])):
</span><span>            height_map[(row, col)] = </span><span style="color:#bf616a;">int</span><span>(data[row][col])
</span><span>    </span><span style="color:#b48ead;">return </span><span>height_map
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day09_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    height_map = </span><span style="color:#bf616a;">make_map</span><span>(data)
</span><span>    risk_level = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc, height </span><span style="color:#b48ead;">in </span><span>height_map.</span><span style="color:#bf616a;">items</span><span>():
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">is_lowest_adjacent</span><span>(height_map, loc):
</span><span>            risk_level += height + </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">return </span><span>risk_level
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">visit_basins</span><span>(</span><span style="color:#bf616a;">height_map</span><span>, </span><span style="color:#bf616a;">loc</span><span>, </span><span style="color:#bf616a;">visited</span><span>=[]):
</span><span>    </span><span style="color:#65737e;"># BFS
</span><span>    visited.</span><span style="color:#bf616a;">append</span><span>(loc)
</span><span>    x, y = loc
</span><span>    directions = [(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>), (</span><span style="color:#d08770;">0</span><span>, -</span><span style="color:#d08770;">1</span><span>), (</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>), (-</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>)]
</span><span>    </span><span style="color:#b48ead;">for </span><span>dx, dy </span><span style="color:#b48ead;">in </span><span>directions:
</span><span>        new_loc = (x+dx, y+dy)
</span><span>        </span><span style="color:#b48ead;">if </span><span>(new_loc not in visited and
</span><span>           new_loc in height_map and
</span><span>           height_map.</span><span style="color:#bf616a;">get</span><span>(new_loc) &lt; </span><span style="color:#d08770;">9</span><span>):
</span><span>            </span><span style="color:#bf616a;">visit_basins</span><span>(height_map, new_loc, visited)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(visited)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day09_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    height_map = </span><span style="color:#bf616a;">make_map</span><span>(data)
</span><span>    basins = []
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc </span><span style="color:#b48ead;">in </span><span>height_map.</span><span style="color:#bf616a;">keys</span><span>():
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">is_lowest_adjacent</span><span>(height_map, loc):
</span><span>            basins.</span><span style="color:#bf616a;">append</span><span>(</span><span style="color:#bf616a;">visit_basins</span><span>(height_map, loc, []))
</span><span>    basins = </span><span style="color:#96b5b4;">sorted</span><span>(basins, </span><span style="color:#bf616a;">reverse</span><span>=</span><span style="color:#d08770;">True</span><span>)
</span><span>    </span><span style="color:#b48ead;">return </span><span>basins[</span><span style="color:#d08770;">0</span><span>] * basins[</span><span style="color:#d08770;">1</span><span>] * basins[</span><span style="color:#d08770;">2</span><span>]
</span></code></pre>
<p>Today is a simple useage of BFS.</p>
<h2 id="day-10-syntax-scoring"><a href="https://adventofcode.com/2021/day/10">Day 10: Syntax Scoring</a></h2>
<p>From today, I will not decribe the puzzle, the complete description will be linked.</p>
<ul>
<li>What is the total syntax error score for those errors?</li>
<li>Find the completion string for each incomplete line, score the completion strings, and sort the scores. What is the middle score</li>
</ul>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">reduce_chunk</span><span>(</span><span style="color:#bf616a;">chunk</span><span>: str):
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">any</span><span>(ch in chunk </span><span style="color:#b48ead;">for </span><span>ch </span><span style="color:#b48ead;">in </span><span>[&#39;</span><span style="color:#a3be8c;">()</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">[]</span><span>&#39;, &#39;</span><span style="color:#d08770;">{}</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">&lt;&gt;</span><span>&#39;]):
</span><span>        new_chunk = (chunk
</span><span>                     .</span><span style="color:#bf616a;">replace</span><span>(&#39;</span><span style="color:#a3be8c;">()</span><span>&#39;, &#39;&#39;)
</span><span>                     .</span><span style="color:#bf616a;">replace</span><span>(&#39;</span><span style="color:#a3be8c;">[]</span><span>&#39;, &#39;&#39;)
</span><span>                     .</span><span style="color:#bf616a;">replace</span><span>(&#39;</span><span style="color:#d08770;">{}</span><span>&#39;, &#39;&#39;)
</span><span>                     .</span><span style="color:#bf616a;">replace</span><span>(&#39;</span><span style="color:#a3be8c;">&lt;&gt;</span><span>&#39;, &#39;&#39;))
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">reduce_chunk</span><span>(new_chunk)
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span>chunk
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day10_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    score = </span><span style="color:#d08770;">0
</span><span>    score_map = {&#39;</span><span style="color:#a3be8c;">)</span><span>&#39;: </span><span style="color:#d08770;">3</span><span>, &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;: </span><span style="color:#d08770;">57</span><span>, &#39;</span><span style="color:#a3be8c;">}</span><span>&#39;: </span><span style="color:#d08770;">1197</span><span>, &#39;</span><span style="color:#a3be8c;">&gt;</span><span>&#39;: </span><span style="color:#d08770;">25137</span><span>}
</span><span>    </span><span style="color:#b48ead;">for </span><span>chunk </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        remain_chunk = </span><span style="color:#bf616a;">reduce_chunk</span><span>(chunk)
</span><span>        corupted_chars = [ch
</span><span>                          </span><span style="color:#b48ead;">for </span><span>ch </span><span style="color:#b48ead;">in </span><span>remain_chunk
</span><span>                          </span><span style="color:#b48ead;">if </span><span>ch in [&#39;</span><span style="color:#a3be8c;">)</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">}</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">&gt;</span><span>&#39;]]
</span><span>        </span><span style="color:#b48ead;">if </span><span>corupted_chars:
</span><span>            score += score_map[corupted_chars[</span><span style="color:#d08770;">0</span><span>]]
</span><span>    </span><span style="color:#b48ead;">return </span><span>score
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">reverse_chunk</span><span>(</span><span style="color:#bf616a;">chunk</span><span>):
</span><span>    </span><span style="color:#65737e;"># reverse the incomplete chunk, will complete the chunk
</span><span>    </span><span style="color:#65737e;"># such as: ([{{ and }}])
</span><span>    new_chunk = chunk[::-</span><span style="color:#d08770;">1</span><span>]
</span><span>    chunk_map = {&#39;</span><span style="color:#a3be8c;">(</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">)</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">[</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">{</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">}</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">&lt;</span><span>&#39;: &#39;</span><span style="color:#a3be8c;">&gt;</span><span>&#39;}
</span><span>    </span><span style="color:#b48ead;">return </span><span>&#39;&#39;.</span><span style="color:#bf616a;">join</span><span>([chunk_map[ch] </span><span style="color:#b48ead;">for </span><span>ch </span><span style="color:#b48ead;">in </span><span>new_chunk])
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day10_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    scores = []
</span><span>    score_map = {&#39;</span><span style="color:#a3be8c;">)</span><span>&#39;: </span><span style="color:#d08770;">1</span><span>, &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;: </span><span style="color:#d08770;">2</span><span>, &#39;</span><span style="color:#a3be8c;">}</span><span>&#39;: </span><span style="color:#d08770;">3</span><span>, &#39;</span><span style="color:#a3be8c;">&gt;</span><span>&#39;: </span><span style="color:#d08770;">4</span><span>}
</span><span>    </span><span style="color:#b48ead;">for </span><span>chunk </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        remain_chunk = </span><span style="color:#bf616a;">reduce_chunk</span><span>(chunk)
</span><span>        corupted_chars = [ch
</span><span>                          </span><span style="color:#b48ead;">for </span><span>ch </span><span style="color:#b48ead;">in </span><span>remain_chunk
</span><span>                          </span><span style="color:#b48ead;">if </span><span>ch in [&#39;</span><span style="color:#a3be8c;">)</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">}</span><span>&#39;, &#39;</span><span style="color:#a3be8c;">&gt;</span><span>&#39;]]
</span><span>        </span><span style="color:#b48ead;">if </span><span>not corupted_chars:
</span><span>            score = </span><span style="color:#d08770;">0
</span><span>            </span><span style="color:#b48ead;">for </span><span>ch </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">reverse_chunk</span><span>(remain_chunk):
</span><span>                score = score * </span><span style="color:#d08770;">5 </span><span>+ score_map[ch]
</span><span>            scores.</span><span style="color:#bf616a;">append</span><span>(score)
</span><span>    middle_index = </span><span style="color:#bf616a;">int</span><span>(</span><span style="color:#96b5b4;">len</span><span>(scores) / </span><span style="color:#d08770;">2</span><span>)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">sorted</span><span>(scores)[middle_index]
</span></code></pre>
<p>A simple usage of recursion. Another approach is to use stack, if the c is open_close, put it into stack, if the c is close_open, pop the stack, after line is completed, the stack should be reduced to corupted and incomplete. And you can here to return the flag of the corupted and incomplete.</p>
<h2 id="day-11-dumbo-octopus"><a href="https://adventofcode.com/2021/day/11">Day 11: Dumbo Octopus</a></h2>
<p>Input be like a 10*10 number map, represent a enery map. After each iteration, the num changes follow the rule:</p>
<ul>
<li>First, the energy level of each octopus increases by 1.</li>
<li>Then, any octopus with an energy level greater than 9 flashes. This increases the energy level of all adjacent octopuses by 1, including octopuses that are diagonally adjacent. If this causes an octopus to have an energy level greater than 9, it also flashes. This process continues as long as new octopuses keep having their energy level increased beyond 9. (An octopus can only flash at most once per step.)</li>
<li>Finally, any octopus that flashed during this step has its energy level set to 0, as it used all of its energy to flash.</li>
</ul>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">make_map</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    energy_map = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data)):
</span><span>        </span><span style="color:#b48ead;">for </span><span>col </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data[row])):
</span><span>            energy_map[(row, col)] = </span><span style="color:#bf616a;">int</span><span>(data[row][col])
</span><span>    </span><span style="color:#b48ead;">return </span><span>energy_map
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">get_neighbors</span><span>(</span><span style="color:#bf616a;">loc</span><span>, </span><span style="color:#bf616a;">energy_map</span><span>):
</span><span>    x, y = loc
</span><span>    directions = [(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>), (</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">1</span><span>), (</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>), (</span><span style="color:#d08770;">1</span><span>, -</span><span style="color:#d08770;">1</span><span>),
</span><span>                  (</span><span style="color:#d08770;">0</span><span>, -</span><span style="color:#d08770;">1</span><span>), (-</span><span style="color:#d08770;">1</span><span>, -</span><span style="color:#d08770;">1</span><span>), (-</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>), (-</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">1</span><span>)]
</span><span>    </span><span style="color:#b48ead;">return </span><span>[(x + dx, y + dy)
</span><span>            </span><span style="color:#b48ead;">for </span><span>dx, dy </span><span style="color:#b48ead;">in </span><span>directions
</span><span>            </span><span style="color:#b48ead;">if </span><span>(x + dx, y + dy) in energy_map]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">update_map</span><span>(</span><span style="color:#bf616a;">energy_map</span><span>, </span><span style="color:#bf616a;">flashed</span><span>=[]):
</span><span>    energy_map = energy_map.</span><span style="color:#bf616a;">copy</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc, energy </span><span style="color:#b48ead;">in </span><span>energy_map.</span><span style="color:#bf616a;">items</span><span>():
</span><span>        </span><span style="color:#b48ead;">if </span><span>energy &gt; </span><span style="color:#d08770;">9 </span><span>and loc not in flashed:
</span><span>            </span><span style="color:#b48ead;">for </span><span>neighbor </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">get_neighbors</span><span>(loc, energy_map):
</span><span>                </span><span style="color:#b48ead;">if </span><span>neighbor not in flashed:
</span><span>                    energy_map[neighbor] += </span><span style="color:#d08770;">1
</span><span>            flashed.</span><span style="color:#bf616a;">append</span><span>(loc)
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">all</span><span>(eneryg &lt;= </span><span style="color:#d08770;">9 </span><span style="color:#b48ead;">for </span><span>loc, eneryg </span><span style="color:#b48ead;">in </span><span>energy_map.</span><span style="color:#bf616a;">items</span><span>()
</span><span>       </span><span style="color:#b48ead;">if </span><span>loc not in flashed):
</span><span>        </span><span style="color:#b48ead;">return </span><span>energy_map
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">update_map</span><span>(energy_map, flashed)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">simulate</span><span>(</span><span style="color:#bf616a;">energy_map</span><span>):
</span><span>    flashes = </span><span style="color:#d08770;">0
</span><span>    energy_map = energy_map.</span><span style="color:#bf616a;">copy</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc, enery </span><span style="color:#b48ead;">in </span><span>energy_map.</span><span style="color:#bf616a;">items</span><span>():
</span><span>        energy_map[loc] = enery + </span><span style="color:#d08770;">1
</span><span>    energy_map = </span><span style="color:#bf616a;">update_map</span><span>(energy_map, [])
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc, energy </span><span style="color:#b48ead;">in </span><span>energy_map.</span><span style="color:#bf616a;">items</span><span>():
</span><span>        </span><span style="color:#b48ead;">if </span><span>energy &gt; </span><span style="color:#d08770;">9</span><span>:
</span><span>            energy_map[loc] = </span><span style="color:#d08770;">0
</span><span>            flashes += </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">return </span><span>flashes, energy_map
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day11_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    energy_map = </span><span style="color:#bf616a;">make_map</span><span>(data)
</span><span>    all_flashes = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">_ </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">100</span><span>):
</span><span>        flashes, energy_map = </span><span style="color:#bf616a;">simulate</span><span>(energy_map)
</span><span>        all_flashes += flashes
</span><span>    </span><span style="color:#b48ead;">return </span><span>all_flashes
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day11_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    energy_map = </span><span style="color:#bf616a;">make_map</span><span>(data)
</span><span>    counter = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>        counter += </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#bf616a;">_</span><span>, energy_map = </span><span style="color:#bf616a;">simulate</span><span>(energy_map)
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">all</span><span>(energy == </span><span style="color:#d08770;">0 </span><span style="color:#b48ead;">for </span><span>energy </span><span style="color:#b48ead;">in </span><span>energy_map.</span><span style="color:#bf616a;">values</span><span>()):
</span><span>            </span><span style="color:#b48ead;">return </span><span>counter
</span></code></pre>
<p>For part one, I made a mistake, I think the update_map will not be recursive at first, and take some time and steps to reliaze it. After fix this, the solution is quite simple.</p>
<p>For part two, I first thought it will be some large number, but it is not. So the solution not require much effort.</p>
<p>Maybe next yeaer, I should build a Grid class be represent the map.</p>
<p>When browsing the internet, I found <a href="https://www.youtube.com/c/JocelynStericker">programmer named Jocelyn Stericker using rust to solve Advent of Code 2021</a> and <a href="https://github.com/norvig/pytudes/blob/main/ipynb/Advent-2021.ipynb">Peter Norvig using python to solve Advent of Code 2021</a>. Usually, I will solve the puzzle on my own first, then see their solution, which is often shorter and clever.</p>
<h2 id="day-12-passage-pathing"><a href="https://adventofcode.com/2021/day/12">Day 12: Passage Pathing</a></h2>
<p>Input be like:<br />
start-A<br />
start-b<br />
A-c<br />
A-b<br />
b-d<br />
A-end<br />
b-end</p>
<ul>
<li>big caves (written in uppercase, like A) and small caves (written in lowercase, like b) .all paths you find should visit small caves at most once, and can visit big caves any number of times.</li>
<li>part1: How many paths through this cave system are there that visit small caves at most once</li>
<li>part2: After reviewing the available paths, you realize you might have time to visit a single small cave <strong>twice</strong>. However, the caves named start and end can only be visited exactly once each. Given these new rules, how many paths through this cave system are there?</li>
</ul>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_map</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    system = </span><span style="color:#bf616a;">defaultdict</span><span>(list)
</span><span>    </span><span style="color:#b48ead;">for </span><span>start, end </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        system[start].</span><span style="color:#bf616a;">append</span><span>(end)
</span><span>        system[end].</span><span style="color:#bf616a;">append</span><span>(start)
</span><span>    </span><span style="color:#b48ead;">return </span><span>system
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">path_visit</span><span>(</span><span style="color:#bf616a;">start</span><span>=&#39;</span><span style="color:#a3be8c;">start</span><span>&#39;, </span><span style="color:#bf616a;">end</span><span>=&#39;</span><span style="color:#a3be8c;">end</span><span>&#39;, </span><span style="color:#bf616a;">system</span><span>=[], </span><span style="color:#bf616a;">gen_node</span><span>=</span><span style="color:#d08770;">None</span><span>):
</span><span>    frontier = [[start]]
</span><span>    </span><span style="color:#b48ead;">while </span><span>frontier:
</span><span>        path = frontier.</span><span style="color:#bf616a;">pop</span><span>(</span><span style="color:#d08770;">0</span><span>)
</span><span>        node = path[-</span><span style="color:#d08770;">1</span><span>]
</span><span>        </span><span style="color:#b48ead;">if </span><span>node == end:
</span><span>            </span><span style="color:#b48ead;">yield </span><span>path
</span><span>        </span><span style="color:#b48ead;">for </span><span>next_node </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">gen_node</span><span>(node, system, path):
</span><span>            path2 = path + [next_node]
</span><span>            frontier.</span><span style="color:#bf616a;">append</span><span>(path2)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">successors</span><span>(</span><span style="color:#bf616a;">node</span><span>, </span><span style="color:#bf616a;">system</span><span>, </span><span style="color:#bf616a;">path</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span>[node
</span><span>            </span><span style="color:#b48ead;">for </span><span>node </span><span style="color:#b48ead;">in </span><span>system[node]
</span><span>            </span><span style="color:#b48ead;">if </span><span>not(node in path and (&#39;</span><span style="color:#a3be8c;">a</span><span>&#39; &lt;= node[</span><span style="color:#d08770;">0</span><span>] &lt;= &#39;</span><span style="color:#a3be8c;">z</span><span>&#39;))]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">successors_v2</span><span>(</span><span style="color:#bf616a;">node</span><span>, </span><span style="color:#bf616a;">system</span><span>, </span><span style="color:#bf616a;">path</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span>[node
</span><span>            </span><span style="color:#b48ead;">for </span><span>node </span><span style="color:#b48ead;">in </span><span>system[node]
</span><span>            </span><span style="color:#b48ead;">if </span><span>not(
</span><span>                (path + [node]).</span><span style="color:#bf616a;">count</span><span>(&#39;</span><span style="color:#a3be8c;">start</span><span>&#39;) &gt; </span><span style="color:#d08770;">1 </span><span>or
</span><span>                (path + [node]).</span><span style="color:#bf616a;">count</span><span>(&#39;</span><span style="color:#a3be8c;">end</span><span>&#39;) &gt; </span><span style="color:#d08770;">1 </span><span>or
</span><span>                (node in path and
</span><span>                 &#39;</span><span style="color:#a3be8c;">a</span><span>&#39; &lt;= node[</span><span style="color:#d08770;">0</span><span>] &lt;= &#39;</span><span style="color:#a3be8c;">z</span><span>&#39; and
</span><span>                 </span><span style="color:#bf616a;">is_biger_than_twice</span><span>(path + [node]))
</span><span>            )]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">is_biger_than_twice</span><span>(</span><span style="color:#bf616a;">path</span><span>):
</span><span>    smalls = [node
</span><span>              </span><span style="color:#b48ead;">for </span><span>node </span><span style="color:#b48ead;">in </span><span>path
</span><span>              </span><span style="color:#b48ead;">if </span><span>&#39;</span><span style="color:#a3be8c;">a</span><span>&#39; &lt;= node[</span><span style="color:#d08770;">0</span><span>] &lt;= &#39;</span><span style="color:#a3be8c;">z</span><span>&#39;]
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(smalls) - </span><span style="color:#96b5b4;">len</span><span>(</span><span style="color:#bf616a;">set</span><span>(smalls)) &gt; </span><span style="color:#d08770;">1
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day12_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    system = </span><span style="color:#bf616a;">gen_map</span><span>(data)
</span><span>    paths = </span><span style="color:#bf616a;">list</span><span>(</span><span style="color:#bf616a;">path_visit</span><span>(</span><span style="color:#bf616a;">start</span><span>=&#39;</span><span style="color:#a3be8c;">start</span><span>&#39;,
</span><span>                            </span><span style="color:#bf616a;">end</span><span>=&#39;</span><span style="color:#a3be8c;">end</span><span>&#39;,
</span><span>                            </span><span style="color:#bf616a;">system</span><span>=system,
</span><span>                            </span><span style="color:#bf616a;">gen_node</span><span>=successors))
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(paths)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day12_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    system = </span><span style="color:#bf616a;">gen_map</span><span>(data)
</span><span>    paths = </span><span style="color:#bf616a;">list</span><span>(</span><span style="color:#bf616a;">path_visit</span><span>(</span><span style="color:#bf616a;">start</span><span>=&#39;</span><span style="color:#a3be8c;">start</span><span>&#39;,
</span><span>                            </span><span style="color:#bf616a;">end</span><span>=&#39;</span><span style="color:#a3be8c;">end</span><span>&#39;,
</span><span>                            </span><span style="color:#bf616a;">system</span><span>=system,
</span><span>                            </span><span style="color:#bf616a;">gen_node</span><span>=successors_v2))
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(paths)
</span></code></pre>
<h2 id="day-13-transparent-origami"><a href="https://adventofcode.com/2021/day/13">Day 13: Transparent Origami</a></h2>
<p>Input be like:</p>
<p>6,10<br />
0,14<br />
9,10<br />
0,3<br />
10,4<br />
4,11<br />
6,0<br />
6,12<br />
4,1<br />
0,13<br />
10,12<br />
3,4<br />
3,0<br />
8,4<br />
1,10<br />
2,14<br />
8,10<br />
9,0</p>
<p>fold along y=7<br />
fold along x=5</p>
<ul>
<li>How many dots are visible after completing just the first fold instruction on your transparent paper</li>
<li>Finish folding the transparent paper according to the instructions. The manual says the code is always eight capital letters. What is the code?</li>
</ul>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_data</span><span>():
</span><span>    data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">13</span><span>, </span><span style="color:#bf616a;">parser</span><span>=str, </span><span style="color:#bf616a;">sep</span><span>=&#39;</span><span style="color:#96b5b4;">\n\n</span><span>&#39;)
</span><span>    dots = [line.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;) </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>data[</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;)]
</span><span>    folds = [re.</span><span style="color:#bf616a;">findall</span><span>(</span><span style="color:#b48ead;">r</span><span>&#39;</span><span style="color:#d08770;">.</span><span>*?</span><span style="color:#a3be8c;">(</span><span style="color:#d08770;">\w</span><span style="color:#a3be8c;">)=(</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">)</span><span>&#39;, line)[</span><span style="color:#d08770;">0</span><span>]
</span><span>             </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>data[</span><span style="color:#d08770;">1</span><span>].</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;)]
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>dots, folds
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">make_map</span><span>(</span><span style="color:#bf616a;">dots</span><span>):
</span><span>    system = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>x, y </span><span style="color:#b48ead;">in </span><span>dots:
</span><span>        system[(</span><span style="color:#bf616a;">int</span><span>(x), </span><span style="color:#bf616a;">int</span><span>(y))] = &#39;</span><span style="color:#a3be8c;">#</span><span>&#39;
</span><span>    </span><span style="color:#b48ead;">return </span><span>system
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">update_dot</span><span>(</span><span style="color:#bf616a;">dota</span><span>, </span><span style="color:#bf616a;">dotb</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span>&#39;</span><span style="color:#a3be8c;">#</span><span>&#39; </span><span style="color:#b48ead;">if </span><span>&#39;</span><span style="color:#a3be8c;">#</span><span>&#39; in [dota, dotb] </span><span style="color:#b48ead;">else </span><span>&#39;</span><span style="color:#a3be8c;">.</span><span>&#39;
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">update_fold_system</span><span>(</span><span style="color:#bf616a;">system</span><span>, </span><span style="color:#bf616a;">axis</span><span>, </span><span style="color:#bf616a;">num</span><span>):
</span><span>    new_system = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>(x, y), dot </span><span style="color:#b48ead;">in </span><span>system.</span><span style="color:#bf616a;">items</span><span>():
</span><span>        </span><span style="color:#b48ead;">if </span><span>axis == &#39;</span><span style="color:#a3be8c;">x</span><span>&#39;:
</span><span>            </span><span style="color:#b48ead;">if </span><span>x &lt;= num:
</span><span>                new_system[(x, y)] = dot
</span><span>            </span><span style="color:#b48ead;">else</span><span>:
</span><span>                new_system[(</span><span style="color:#d08770;">2</span><span>*num - x, y)] = </span><span style="color:#bf616a;">update_dot</span><span>(system[(x, y)], dot)
</span><span>        </span><span style="color:#b48ead;">if </span><span>axis == &#39;</span><span style="color:#a3be8c;">y</span><span>&#39;:
</span><span>            </span><span style="color:#b48ead;">if </span><span>y &lt;= num:
</span><span>                new_system[(x, y)] = dot
</span><span>            </span><span style="color:#b48ead;">else</span><span>:
</span><span>                new_system[(x, </span><span style="color:#d08770;">2</span><span>*num - y)] = </span><span style="color:#bf616a;">update_dot</span><span>(system[(x, y)], dot)
</span><span>    </span><span style="color:#b48ead;">return </span><span>new_system
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day13_1</span><span>(</span><span style="color:#bf616a;">dots</span><span>, </span><span style="color:#bf616a;">folds</span><span>):
</span><span>    system = </span><span style="color:#bf616a;">make_map</span><span>(dots)
</span><span>    </span><span style="color:#b48ead;">for </span><span>axis, num </span><span style="color:#b48ead;">in </span><span>folds[:</span><span style="color:#d08770;">1</span><span>]:
</span><span>        system = </span><span style="color:#bf616a;">update_fold_system</span><span>(system, axis, </span><span style="color:#bf616a;">int</span><span>(num))
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">list</span><span>(system.</span><span style="color:#bf616a;">values</span><span>()).</span><span style="color:#bf616a;">count</span><span>(&#39;</span><span style="color:#a3be8c;">#</span><span>&#39;)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">print_map</span><span>(</span><span style="color:#bf616a;">system</span><span>):
</span><span>    x = </span><span style="color:#96b5b4;">max</span><span>(system, </span><span style="color:#bf616a;">key</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x[</span><span style="color:#d08770;">0</span><span>])[</span><span style="color:#d08770;">0</span><span>]
</span><span>    y = </span><span style="color:#96b5b4;">max</span><span>(system, </span><span style="color:#bf616a;">key</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: x[</span><span style="color:#d08770;">1</span><span>])[</span><span style="color:#d08770;">1</span><span>]
</span><span>    </span><span style="color:#b48ead;">for </span><span>dy </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(y + </span><span style="color:#d08770;">1</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>dx </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(x + </span><span style="color:#d08770;">1</span><span>):
</span><span>            </span><span style="color:#96b5b4;">print</span><span>(system.</span><span style="color:#bf616a;">get</span><span>((dx, dy), &#39; &#39;), </span><span style="color:#bf616a;">end</span><span>=&#39;&#39;)
</span><span>        </span><span style="color:#96b5b4;">print</span><span>()
</span><span>    </span><span style="color:#96b5b4;">print</span><span>()
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day13_2</span><span>(</span><span style="color:#bf616a;">dots</span><span>, </span><span style="color:#bf616a;">folds</span><span>):
</span><span>    system = </span><span style="color:#bf616a;">make_map</span><span>(dots)
</span><span>    </span><span style="color:#b48ead;">for </span><span>axis, num </span><span style="color:#b48ead;">in </span><span>folds:
</span><span>        system = </span><span style="color:#bf616a;">update_fold_system</span><span>(system, axis, </span><span style="color:#bf616a;">int</span><span>(num))
</span><span>    </span><span style="color:#65737e;"># ZKAUCFUC
</span><span>    </span><span style="color:#bf616a;">print_map</span><span>(system)
</span></code></pre>
<h2 id="day-14-extended-polymerization"><a href="https://adventofcode.com/2021/day/14">Day 14: Extended Polymerization</a></h2>
<p>Input is two part, first is the polymer template, second is a list of pair insertion rules.</p>
<p>NNCB</p>
<p>CH -&gt; B<br />
HH -&gt; N<br />
CB -&gt; H<br />
NH -&gt; C<br />
HB -&gt; C<br />
HC -&gt; B<br />
HN -&gt; C<br />
NN -&gt; C<br />
BH -&gt; H<br />
NC -&gt; B<br />
NB -&gt; B<br />
BN -&gt; B<br />
BB -&gt; N<br />
BC -&gt; B<br />
CC -&gt; N<br />
CN -&gt; C</p>
<p>A rule like AB -&gt; C means that when elements A and B are immediately adjacent, element C should be inserted between them. These insertions all happen simultaneously.Note that these pairs overlap: the second element of one pair is the first element of the next pair. Also, because all pairs are considered simultaneously, inserted elements are not considered to be part of a pair until the next step.</p>
<ul>
<li>part1: after 10 steps, what is quantity of the most common element and subtract the quantity of the least common element</li>
<li>part2: after 400 steps, what is quantity of the most common element and subtract the quantity of the least common element</li>
</ul>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_data</span><span>():
</span><span>    pair_insertion_ruls = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">14</span><span>, </span><span style="color:#bf616a;">sep</span><span>=&#39;</span><span style="color:#96b5b4;">\n\n</span><span>&#39;)
</span><span>    template = data[</span><span style="color:#d08770;">0</span><span>]
</span><span>    </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>data[</span><span style="color:#d08770;">1</span><span>].</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;):
</span><span>        key, val = line.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;"> -&gt; </span><span>&#39;)
</span><span>        pair_insertion_ruls[key] = val
</span><span>    </span><span style="color:#b48ead;">return </span><span>template, pair_insertion_ruls
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">simulate</span><span>(</span><span style="color:#bf616a;">template</span><span>, </span><span style="color:#bf616a;">pair_insertion_ruls</span><span>):
</span><span>    new_template = &#39;&#39;
</span><span>    </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(template) - </span><span style="color:#d08770;">1</span><span>):
</span><span>        left_char = template[i]
</span><span>        right_char = template[i + </span><span style="color:#d08770;">1</span><span>]
</span><span>        insert_char = pair_insertion_ruls[left_char + right_char]
</span><span>        new_template += left_char + insert_char
</span><span>    new_template += template[-</span><span style="color:#d08770;">1</span><span>]
</span><span>    </span><span style="color:#b48ead;">return </span><span>new_template
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day14_1</span><span>(</span><span style="color:#bf616a;">template</span><span>, </span><span style="color:#bf616a;">pair_insertion_ruls</span><span>):
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">_ </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">10</span><span>):
</span><span>        template = </span><span style="color:#bf616a;">simulate</span><span>(template, pair_insertion_ruls)
</span><span>
</span><span>    counter = </span><span style="color:#bf616a;">Counter</span><span>(template)
</span><span>    most_common = counter.</span><span style="color:#bf616a;">most_common</span><span>(</span><span style="color:#d08770;">1</span><span>)[</span><span style="color:#d08770;">0</span><span>][</span><span style="color:#d08770;">1</span><span>]
</span><span>    least_common = counter.</span><span style="color:#bf616a;">most_common</span><span>()[-</span><span style="color:#d08770;">1</span><span>][</span><span style="color:#d08770;">1</span><span>]
</span><span>    </span><span style="color:#b48ead;">return </span><span>most_common - least_common
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day14_2</span><span>(</span><span style="color:#bf616a;">template</span><span>, </span><span style="color:#bf616a;">pair_insertion_ruls</span><span>):
</span><span>    symbols_occurences = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    </span><span style="color:#b48ead;">for </span><span>x </span><span style="color:#b48ead;">in </span><span>template:
</span><span>        symbols_occurences[x] += </span><span style="color:#d08770;">1
</span><span>
</span><span>    twograms_occurences = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(template) - </span><span style="color:#d08770;">1</span><span>):
</span><span>        x = template[i]
</span><span>        y = template[i + </span><span style="color:#d08770;">1</span><span>]
</span><span>        twograms_occurences[x + y] += </span><span style="color:#d08770;">1
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">_ </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">40</span><span>):
</span><span>        new_insertions = []
</span><span>        </span><span style="color:#b48ead;">for </span><span>pair, symbol </span><span style="color:#b48ead;">in </span><span>pair_insertion_ruls.</span><span style="color:#bf616a;">items</span><span>():
</span><span>            </span><span style="color:#b48ead;">if </span><span>pair in twograms_occurences:
</span><span>                new_insertions.</span><span style="color:#bf616a;">append</span><span>(
</span><span>                    (pair, symbol, twograms_occurences[pair]))
</span><span>                </span><span style="color:#b48ead;">del </span><span>twograms_occurences[pair]
</span><span>        </span><span style="color:#b48ead;">for </span><span>pair, symbol, cnt </span><span style="color:#b48ead;">in </span><span>new_insertions:
</span><span>            symbols_occurences[symbol] += cnt
</span><span>            twograms_occurences[pair[</span><span style="color:#d08770;">0</span><span>] + symbol] += cnt
</span><span>            twograms_occurences[symbol + pair[</span><span style="color:#d08770;">1</span><span>]] += cnt
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">max</span><span>(symbols_occurences.</span><span style="color:#bf616a;">values</span><span>()) - </span><span style="color:#96b5b4;">min</span><span>(symbols_occurences.</span><span style="color:#bf616a;">values</span><span>())
</span></code></pre>
<p>The idea to solve part 1 is to simulate and store the template, which works fine. But for part 2 the length of final template is more than 2 trillion. There is no data strutures to store it, so a different approach is needed.</p>
<p>Part 2 is mostly reference some great post on this <a href="https://www.reddit.com/r/adventofcode/">subreddit</a>.</p>
<h2 id="day-15-chiton"><a href="https://adventofcode.com/2021/day/15">Day 15: Chiton</a></h2>
<p>Input is a 2D array of integers, representing the risk map. Such as:
1163751742<br />
1381373672<br />
2136511328<br />
3694931569<br />
7463417111<br />
1319128137<br />
1359912421<br />
3125421639<br />
1293138521<br />
2311944581</p>
<p>Part1: What is the lowest total risk of any path from the top left to the bottom right?</p>
<p>Part2: The actual map is the current map repeat to right or down five times. And after each repeation, the risk are 1 higher, but risk levels above 9 wrap back around to 1. With this new information, what is the lowest total risk of any path from the top left to the bottom right?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">from </span><span>queue </span><span style="color:#b48ead;">import </span><span>PriorityQueue
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">make_map</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span>{(row, col): </span><span style="color:#bf616a;">int</span><span>(data[row][col])
</span><span>            </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data))
</span><span>            </span><span style="color:#b48ead;">for </span><span>col </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(data[row]))}
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">print_map</span><span>(</span><span style="color:#bf616a;">energy_map</span><span>):
</span><span>    loc = </span><span style="color:#bf616a;">list</span><span>(energy_map.</span><span style="color:#bf616a;">keys</span><span>())[-</span><span style="color:#d08770;">1</span><span>]
</span><span>    x, y = loc
</span><span>    </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(x + </span><span style="color:#d08770;">1</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>col </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(y + </span><span style="color:#d08770;">1</span><span>):
</span><span>            </span><span style="color:#96b5b4;">print</span><span>(energy_map[(row, col)], </span><span style="color:#bf616a;">end</span><span>=&#39;&#39;)
</span><span>        </span><span style="color:#96b5b4;">print</span><span>()
</span><span>    </span><span style="color:#96b5b4;">print</span><span>()
</span><span>
</span><span>
</span><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Graph</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">num_of_vertices</span><span>):
</span><span>        </span><span style="color:#bf616a;">self</span><span>.v = num_of_vertices*num_of_vertices
</span><span>        </span><span style="color:#bf616a;">self</span><span>.edges = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>        </span><span style="color:#bf616a;">self</span><span>.nodes = [(i, j)
</span><span>                      </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(num_of_vertices)
</span><span>                      </span><span style="color:#b48ead;">for </span><span>j </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(num_of_vertices)]
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">add_edge</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">u</span><span>, </span><span style="color:#bf616a;">v</span><span>, </span><span style="color:#bf616a;">weight</span><span>):
</span><span>        </span><span style="color:#b48ead;">if </span><span>u in </span><span style="color:#bf616a;">self</span><span>.nodes and v in </span><span style="color:#bf616a;">self</span><span>.nodes:
</span><span>            </span><span style="color:#bf616a;">self</span><span>.edges[(u, v)] = weight
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">add_edge_with_map</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">risk_map</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>node, risk </span><span style="color:#b48ead;">in </span><span>risk_map.</span><span style="color:#bf616a;">items</span><span>():
</span><span>            </span><span style="color:#b48ead;">for </span><span>neighbor </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">neighbors</span><span>(node):
</span><span>                </span><span style="color:#b48ead;">if </span><span>neighbor in risk_map:
</span><span>                    </span><span style="color:#bf616a;">self</span><span>.edges[(neighbor, node)] = risk
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">neighbors</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">loc</span><span>):
</span><span>        x, y = loc
</span><span>        directions = [(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1</span><span>), (</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>), (</span><span style="color:#d08770;">0</span><span>, -</span><span style="color:#d08770;">1</span><span>), (-</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0</span><span>)]
</span><span>        </span><span style="color:#b48ead;">return </span><span>[(x + dx, y + dy) </span><span style="color:#b48ead;">for </span><span>dx, dy </span><span style="color:#b48ead;">in </span><span>directions]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">dijkstra</span><span>(</span><span style="color:#bf616a;">graph</span><span>, </span><span style="color:#bf616a;">source</span><span>):
</span><span>    dist = {node: </span><span style="color:#bf616a;">float</span><span>(&#39;</span><span style="color:#a3be8c;">inf</span><span>&#39;) </span><span style="color:#b48ead;">for </span><span>node </span><span style="color:#b48ead;">in </span><span>graph.nodes}
</span><span>    prev = {node: </span><span style="color:#d08770;">None </span><span style="color:#b48ead;">for </span><span>node </span><span style="color:#b48ead;">in </span><span>graph.nodes}
</span><span>    dist[source] = </span><span style="color:#d08770;">0
</span><span>    q = </span><span style="color:#bf616a;">PriorityQueue</span><span>()
</span><span>    q.</span><span style="color:#bf616a;">put</span><span>((</span><span style="color:#d08770;">0</span><span>, source))
</span><span>    </span><span style="color:#b48ead;">while </span><span>not q.</span><span style="color:#bf616a;">empty</span><span>():
</span><span>        u = q.</span><span style="color:#bf616a;">get</span><span>()[</span><span style="color:#d08770;">1</span><span>]
</span><span>        </span><span style="color:#b48ead;">for </span><span>v </span><span style="color:#b48ead;">in </span><span>graph.</span><span style="color:#bf616a;">neighbors</span><span>(u):
</span><span>            </span><span style="color:#b48ead;">if </span><span>((u, v) in graph.edges and
</span><span>               dist[v] &gt; dist[u] + graph.edges[(u, v)]):
</span><span>                dist[v] = dist[u] + graph.edges[(u, v)]
</span><span>                q.</span><span style="color:#bf616a;">put</span><span>((dist[v], v))
</span><span>                prev[v] = u
</span><span>    </span><span style="color:#b48ead;">return </span><span>dist, prev
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">print_result</span><span>(</span><span style="color:#bf616a;">previous_nodes</span><span>, </span><span style="color:#bf616a;">shortest_path</span><span>, </span><span style="color:#bf616a;">start_node</span><span>, </span><span style="color:#bf616a;">target_node</span><span>):
</span><span>    path = []
</span><span>    node = target_node
</span><span>
</span><span>    </span><span style="color:#b48ead;">while </span><span>node != start_node:
</span><span>        path.</span><span style="color:#bf616a;">append</span><span>(node)
</span><span>        node = previous_nodes[node]
</span><span>
</span><span>    </span><span style="color:#65737e;"># Add the start node manually
</span><span>    path.</span><span style="color:#bf616a;">append</span><span>(start_node)
</span><span>
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&quot;</span><span style="color:#a3be8c;">We found the following best path with a value of </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">.</span><span>&quot;.</span><span style="color:#bf616a;">format</span><span>(
</span><span>        shortest_path[target_node]))
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&quot;</span><span style="color:#a3be8c;"> -&gt; </span><span>&quot;.</span><span style="color:#bf616a;">join</span><span>(</span><span style="color:#bf616a;">str</span><span>(elem) </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">reversed</span><span>(path)))
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">solver</span><span>(</span><span style="color:#bf616a;">risk_map</span><span>):
</span><span>    last_element = </span><span style="color:#bf616a;">list</span><span>(risk_map.</span><span style="color:#bf616a;">keys</span><span>())[-</span><span style="color:#d08770;">1</span><span>]
</span><span>
</span><span>    graph = </span><span style="color:#bf616a;">Graph</span><span>(last_element[</span><span style="color:#d08770;">0</span><span>] + </span><span style="color:#d08770;">1</span><span>)
</span><span>    graph.</span><span style="color:#bf616a;">add_edge_with_map</span><span>(risk_map)
</span><span>
</span><span>    source = </span><span style="color:#bf616a;">list</span><span>(risk_map.</span><span style="color:#bf616a;">keys</span><span>())[</span><span style="color:#d08770;">0</span><span>]
</span><span>
</span><span>    dist, </span><span style="color:#bf616a;">_ </span><span>= </span><span style="color:#bf616a;">dijkstra</span><span>(graph, source)
</span><span>    </span><span style="color:#b48ead;">return </span><span>dist[last_element]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day15_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    risk_map = </span><span style="color:#bf616a;">make_map</span><span>(data)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">solver</span><span>(risk_map)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">below_to_nine</span><span>(</span><span style="color:#bf616a;">num</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span>num % </span><span style="color:#d08770;">9 </span><span style="color:#b48ead;">if </span><span>num != </span><span style="color:#d08770;">9 </span><span style="color:#b48ead;">else </span><span style="color:#d08770;">9
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">extend_map</span><span>(</span><span style="color:#bf616a;">risk_map</span><span>):
</span><span>    new_risk_map = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    dimension = </span><span style="color:#bf616a;">list</span><span>(risk_map.</span><span style="color:#bf616a;">keys</span><span>())[-</span><span style="color:#d08770;">1</span><span>][</span><span style="color:#d08770;">0</span><span>] + </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">5</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>loc, risk </span><span style="color:#b48ead;">in </span><span>risk_map.</span><span style="color:#bf616a;">items</span><span>():
</span><span>            new_risk_map[(loc[</span><span style="color:#d08770;">0</span><span>], loc[</span><span style="color:#d08770;">1</span><span>]+i*dimension)] = </span><span style="color:#bf616a;">below_to_nine</span><span>(risk+i)
</span><span>    final_map = </span><span style="color:#bf616a;">defaultdict</span><span>(int)
</span><span>    </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">5</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>loc, risk </span><span style="color:#b48ead;">in </span><span>new_risk_map.</span><span style="color:#bf616a;">items</span><span>():
</span><span>            final_map[(loc[</span><span style="color:#d08770;">0</span><span>] + i*dimension, loc[</span><span style="color:#d08770;">1</span><span>])] = </span><span style="color:#bf616a;">below_to_nine</span><span>(risk+i)
</span><span>    </span><span style="color:#b48ead;">return </span><span>final_map
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day15_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    risk_map = </span><span style="color:#bf616a;">make_map</span><span>(data)
</span><span>    risk_map = </span><span style="color:#bf616a;">extend_map</span><span>(risk_map)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">solver</span><span>(risk_map)
</span></code></pre>
<p>Today I learned about the Dijkstra's algorithm, which is used to find the shortest path between two nodes in a graph. Since I know little about it, a lot of time was spent on the algorithm. But after implementing it, the code become much easier.</p>
<h2 id="day-16-packet-decoder"><a href="https://adventofcode.com/2021/day/16">Day 16: Packet Decoder</a></h2>
<p>You have a hexadecimal input string(such as: D2FE28), first it will be convert to binary, follow a rule(such as: A=1010) which could be parse into data and oporation packet.</p>
<p>Part1: Decode the structure of your hexadecimal-encoded BITS transmission; what do you get if you add up the version numbers in all packets?</p>
<p>Part2: With the given operation rule, What do you get if you evaluate the expression represented by your hexadecimal-encoded BITS transmission?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span>hex_map = {
</span><span>    &quot;</span><span style="color:#a3be8c;">0</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">0000</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">1</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">0001</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">2</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">0010</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">3</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">0011</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">4</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">0100</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">5</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">0101</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">6</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">0110</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">7</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">0111</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">8</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1000</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">9</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1001</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">A</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1010</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">B</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1011</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">C</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1100</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">D</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1101</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">E</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1110</span><span>&quot;,
</span><span>    &quot;</span><span style="color:#a3be8c;">F</span><span>&quot;: &quot;</span><span style="color:#a3be8c;">1111</span><span>&quot;
</span><span>}
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">parse_literals</span><span>(</span><span style="color:#bf616a;">bits</span><span>):
</span><span>    five_bits = bits[:</span><span style="color:#d08770;">5</span><span>]
</span><span>    </span><span style="color:#b48ead;">if </span><span>five_bits[</span><span style="color:#d08770;">0</span><span>] == &#39;</span><span style="color:#a3be8c;">0</span><span>&#39;:
</span><span>        </span><span style="color:#b48ead;">return </span><span>five_bits
</span><span>    </span><span style="color:#b48ead;">return </span><span>five_bits + </span><span style="color:#bf616a;">parse_literals</span><span>(bits[</span><span style="color:#d08770;">5</span><span>:])
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">parse_packets</span><span>(</span><span style="color:#bf616a;">bits</span><span>):
</span><span>    version = </span><span style="color:#bf616a;">int</span><span>(bits[:</span><span style="color:#d08770;">3</span><span>], </span><span style="color:#d08770;">2</span><span>)
</span><span>    type_ID = </span><span style="color:#bf616a;">int</span><span>(bits[</span><span style="color:#d08770;">3</span><span>:</span><span style="color:#d08770;">6</span><span>], </span><span style="color:#d08770;">2</span><span>)
</span><span>    </span><span style="color:#b48ead;">if </span><span>type_ID == </span><span style="color:#d08770;">4</span><span>:
</span><span>        </span><span style="color:#65737e;"># literal value
</span><span>        num_bits = </span><span style="color:#bf616a;">parse_literals</span><span>(bits[</span><span style="color:#d08770;">6</span><span>:])
</span><span>        num_filted = &#39;&#39;.</span><span style="color:#bf616a;">join</span><span>(num_bits[i]
</span><span>                             </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#96b5b4;">len</span><span>(num_bits))
</span><span>                             </span><span style="color:#b48ead;">if </span><span>i % </span><span style="color:#d08770;">5 </span><span>!= </span><span style="color:#d08770;">0</span><span>)
</span><span>        num = </span><span style="color:#bf616a;">int</span><span>(num_filted, </span><span style="color:#d08770;">2</span><span>)
</span><span>        </span><span style="color:#b48ead;">return </span><span>{&quot;</span><span style="color:#a3be8c;">version</span><span>&quot;: version,
</span><span>                &quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;: type_ID,
</span><span>                &quot;</span><span style="color:#a3be8c;">literal</span><span>&quot;: num,
</span><span>                &quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;: </span><span style="color:#d08770;">None</span><span>,
</span><span>                &quot;</span><span style="color:#a3be8c;">bits</span><span>&quot;: bits[:</span><span style="color:#d08770;">6</span><span>] + num_bits}
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#65737e;"># an operator
</span><span>        bit_label = bits[</span><span style="color:#d08770;">6</span><span>]
</span><span>        </span><span style="color:#b48ead;">if </span><span>bit_label == &#39;</span><span style="color:#a3be8c;">0</span><span>&#39;:
</span><span>            total_sub_length = </span><span style="color:#bf616a;">int</span><span>(bits[</span><span style="color:#d08770;">7</span><span>:</span><span style="color:#d08770;">7</span><span>+</span><span style="color:#d08770;">15</span><span>], </span><span style="color:#d08770;">2</span><span>)
</span><span>            sub_bits = bits[</span><span style="color:#d08770;">7</span><span>+</span><span style="color:#d08770;">15</span><span>:]
</span><span>            occupy_bits = bits[:</span><span style="color:#d08770;">7</span><span>+</span><span style="color:#d08770;">15</span><span>]
</span><span>            sub_packets = []
</span><span>            </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>                sub = </span><span style="color:#bf616a;">parse_packets</span><span>(sub_bits)
</span><span>                sub_packets.</span><span style="color:#bf616a;">append</span><span>(sub)
</span><span>                sub_bits = sub_bits[</span><span style="color:#96b5b4;">len</span><span>(sub[&quot;</span><span style="color:#a3be8c;">bits</span><span>&quot;]):]
</span><span>                occupy_bits += bits[</span><span style="color:#96b5b4;">len</span><span>(occupy_bits):
</span><span>                                    </span><span style="color:#96b5b4;">len</span><span>(occupy_bits)+</span><span style="color:#96b5b4;">len</span><span>(sub[&quot;</span><span style="color:#a3be8c;">bits</span><span>&quot;])]
</span><span>                </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#96b5b4;">sum</span><span>(</span><span style="color:#96b5b4;">len</span><span>(sub[&quot;</span><span style="color:#a3be8c;">bits</span><span>&quot;]) </span><span style="color:#b48ead;">for </span><span>sub </span><span style="color:#b48ead;">in </span><span>sub_packets)
</span><span>                   &gt;= total_sub_length):
</span><span>                    </span><span style="color:#b48ead;">return </span><span>{&quot;</span><span style="color:#a3be8c;">version</span><span>&quot;: version,
</span><span>                            &quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;: type_ID,
</span><span>                            &quot;</span><span style="color:#a3be8c;">operator</span><span>&quot;: bit_label,
</span><span>                            &quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;: sub_packets,
</span><span>                            &quot;</span><span style="color:#a3be8c;">bits</span><span>&quot;: occupy_bits}
</span><span>        </span><span style="color:#b48ead;">elif </span><span>bit_label == &#39;</span><span style="color:#a3be8c;">1</span><span>&#39;:
</span><span>            num_sub_packets = </span><span style="color:#bf616a;">int</span><span>(bits[</span><span style="color:#d08770;">7</span><span>:</span><span style="color:#d08770;">7</span><span>+</span><span style="color:#d08770;">11</span><span>], </span><span style="color:#d08770;">2</span><span>)
</span><span>            sub_bits = bits[</span><span style="color:#d08770;">7</span><span>+</span><span style="color:#d08770;">11</span><span>:]
</span><span>            occupy_bits = bits[:</span><span style="color:#d08770;">7</span><span>+</span><span style="color:#d08770;">11</span><span>]
</span><span>            sub_packets = []
</span><span>            </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">_ </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(num_sub_packets):
</span><span>                sub = </span><span style="color:#bf616a;">parse_packets</span><span>(sub_bits)
</span><span>                sub_packets.</span><span style="color:#bf616a;">append</span><span>(sub)
</span><span>                sub_bits = sub_bits[</span><span style="color:#96b5b4;">len</span><span>(sub[&quot;</span><span style="color:#a3be8c;">bits</span><span>&quot;]):]
</span><span>                occupy_bits += bits[</span><span style="color:#96b5b4;">len</span><span>(occupy_bits):
</span><span>                                    </span><span style="color:#96b5b4;">len</span><span>(occupy_bits)+</span><span style="color:#96b5b4;">len</span><span>(sub[&quot;</span><span style="color:#a3be8c;">bits</span><span>&quot;])]
</span><span>            </span><span style="color:#b48ead;">return </span><span>{&quot;</span><span style="color:#a3be8c;">version</span><span>&quot;: version,
</span><span>                    &quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;: type_ID,
</span><span>                    &quot;</span><span style="color:#a3be8c;">operator</span><span>&quot;: bit_label,
</span><span>                    &quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;: sub_packets,
</span><span>                    &quot;</span><span style="color:#a3be8c;">bits</span><span>&quot;: occupy_bits}
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">sum_version</span><span>(</span><span style="color:#bf616a;">packets</span><span>):
</span><span>    </span><span style="color:#b48ead;">if </span><span>not packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;]:
</span><span>        </span><span style="color:#b48ead;">return </span><span>packets[&quot;</span><span style="color:#a3be8c;">version</span><span>&quot;]
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span>packets[&quot;</span><span style="color:#a3be8c;">version</span><span>&quot;] + </span><span style="color:#96b5b4;">sum</span><span>(</span><span style="color:#bf616a;">sum_version</span><span>(sub)
</span><span>                                        </span><span style="color:#b48ead;">for </span><span>sub </span><span style="color:#b48ead;">in </span><span>packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;])
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day16_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    bits = &#39;&#39;.</span><span style="color:#bf616a;">join</span><span>(hex_map[elem] </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>data[</span><span style="color:#d08770;">0</span><span>])
</span><span>    packets = </span><span style="color:#bf616a;">parse_packets</span><span>(bits)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">sum_version</span><span>(packets)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">evaluate</span><span>(</span><span style="color:#bf616a;">packets</span><span>):
</span><span>    </span><span style="color:#b48ead;">if </span><span>packets[&quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;] == </span><span style="color:#d08770;">4</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span>packets[&quot;</span><span style="color:#a3be8c;">literal</span><span>&quot;]
</span><span>    </span><span style="color:#b48ead;">elif </span><span>packets[&quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;] == </span><span style="color:#d08770;">0</span><span>:
</span><span>        </span><span style="color:#65737e;"># sum
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">sum</span><span>(</span><span style="color:#bf616a;">evaluate</span><span>(sub) </span><span style="color:#b48ead;">for </span><span>sub </span><span style="color:#b48ead;">in </span><span>packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;])
</span><span>    </span><span style="color:#b48ead;">elif </span><span>packets[&quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;] == </span><span style="color:#d08770;">1</span><span>:
</span><span>        </span><span style="color:#65737e;"># product
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">reduce</span><span>(</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>: x*y,
</span><span>                      [</span><span style="color:#bf616a;">evaluate</span><span>(sub) </span><span style="color:#b48ead;">for </span><span>sub </span><span style="color:#b48ead;">in </span><span>packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;]])
</span><span>    </span><span style="color:#b48ead;">elif </span><span>packets[&quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;] == </span><span style="color:#d08770;">2</span><span>:
</span><span>        </span><span style="color:#65737e;"># min
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">min</span><span>(</span><span style="color:#bf616a;">evaluate</span><span>(sub) </span><span style="color:#b48ead;">for </span><span>sub </span><span style="color:#b48ead;">in </span><span>packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;])
</span><span>    </span><span style="color:#b48ead;">elif </span><span>packets[&quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;] == </span><span style="color:#d08770;">3</span><span>:
</span><span>        </span><span style="color:#65737e;"># max
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">max</span><span>(</span><span style="color:#bf616a;">evaluate</span><span>(sub) </span><span style="color:#b48ead;">for </span><span>sub </span><span style="color:#b48ead;">in </span><span>packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;])
</span><span>    </span><span style="color:#b48ead;">elif </span><span>packets[&quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;] == </span><span style="color:#d08770;">5</span><span>:
</span><span>        </span><span style="color:#65737e;"># greater than
</span><span>        </span><span style="color:#b48ead;">return </span><span>(</span><span style="color:#d08770;">1
</span><span>                </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">evaluate</span><span>(packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;][</span><span style="color:#d08770;">0</span><span>]) &gt;
</span><span>                    </span><span style="color:#bf616a;">evaluate</span><span>(packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;][</span><span style="color:#d08770;">1</span><span>]))
</span><span>                </span><span style="color:#b48ead;">else </span><span style="color:#d08770;">0</span><span>)
</span><span>    </span><span style="color:#b48ead;">elif </span><span>packets[&quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;] == </span><span style="color:#d08770;">6</span><span>:
</span><span>        </span><span style="color:#65737e;"># less than
</span><span>        </span><span style="color:#b48ead;">return </span><span>(</span><span style="color:#d08770;">1
</span><span>                </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">evaluate</span><span>(packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;][</span><span style="color:#d08770;">0</span><span>]) &lt;
</span><span>                    </span><span style="color:#bf616a;">evaluate</span><span>(packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;][</span><span style="color:#d08770;">1</span><span>]))
</span><span>                </span><span style="color:#b48ead;">else </span><span style="color:#d08770;">0</span><span>)
</span><span>    </span><span style="color:#b48ead;">elif </span><span>packets[&quot;</span><span style="color:#a3be8c;">type_ID</span><span>&quot;] == </span><span style="color:#d08770;">7</span><span>:
</span><span>        </span><span style="color:#65737e;"># equal
</span><span>        </span><span style="color:#b48ead;">return </span><span>(</span><span style="color:#d08770;">1
</span><span>                </span><span style="color:#b48ead;">if </span><span>(</span><span style="color:#bf616a;">evaluate</span><span>(packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;][</span><span style="color:#d08770;">0</span><span>]) ==
</span><span>                    </span><span style="color:#bf616a;">evaluate</span><span>(packets[&quot;</span><span style="color:#a3be8c;">sub-packets</span><span>&quot;][</span><span style="color:#d08770;">1</span><span>]))
</span><span>                </span><span style="color:#b48ead;">else </span><span style="color:#d08770;">0</span><span>)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day16_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    bits = &#39;&#39;.</span><span style="color:#bf616a;">join</span><span>(hex_map[elem] </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>data[</span><span style="color:#d08770;">0</span><span>])
</span><span>    packets = </span><span style="color:#bf616a;">parse_packets</span><span>(bits)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">evaluate</span><span>(packets)
</span></code></pre>
<p>It's a long day, since there are so many rules to parse the packets. The tricky part is to figure out the data structure to represent the packets. After relizing the packet may be recursive containing other packet, I finally choose json-like data structure to store the packets.</p>
<p>The code is a little bit messy, maybe I will refactor it later or maybe not.</p>
<h2 id="day-17-trick-shot"><a href="http://adventofcode.com/2021/day/17">Day 17: Trick Shot</a></h2>
<p>Input represents the an area of grid, which covered by trajectory. The probe starts from (0, 0), with each iter, the location change by rule with velocity who's loc also change ervery step. The velocity is represented by a tuple of (x, y). For special velocity, the probe will within or not within the target area after some steps.</p>
<p>Part1: Find the initial velocity that causes the probe to reach the highest y position and still eventually be within the target area after any step. What is the highest y position it reaches on this trajectory.</p>
<p>Part2: How many distinct initial velocity values cause the probe to be within the target area after any step</p>
<pre data-lang="python" style="background-color:#2b303b;color:#c0c5ce;" class="language-python "><code class="language-python" data-lang="python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">move_once</span><span>(</span><span style="color:#bf616a;">probe_loc</span><span>, </span><span style="color:#bf616a;">velocity</span><span>):
</span><span>    x, y = probe_loc
</span><span>    dx, dy = velocity
</span><span>    new_probe_loc = (x + dx, y + dy)
</span><span>    </span><span style="color:#b48ead;">if </span><span>dx == </span><span style="color:#d08770;">0</span><span>:
</span><span>        new_velocity_x = dx
</span><span>    </span><span style="color:#b48ead;">elif </span><span>dx &gt; </span><span style="color:#d08770;">0</span><span>:
</span><span>        new_velocity_x = dx - </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        new_velocity_x = dx + </span><span style="color:#d08770;">1
</span><span>    new_velocity = (new_velocity_x, dy - </span><span style="color:#d08770;">1</span><span>)
</span><span>    </span><span style="color:#b48ead;">return </span><span>new_probe_loc, new_velocity
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">simulate</span><span>(</span><span style="color:#bf616a;">x0</span><span>, </span><span style="color:#bf616a;">x1</span><span>, </span><span style="color:#bf616a;">y0</span><span>, </span><span style="color:#bf616a;">y1</span><span>, </span><span style="color:#bf616a;">velocity</span><span>):
</span><span>    probe_loc = (</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>)
</span><span>    path = []
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>        probe_loc, velocity = </span><span style="color:#bf616a;">move_once</span><span>(probe_loc, velocity)
</span><span>        path.</span><span style="color:#bf616a;">append</span><span>(probe_loc)
</span><span>        x, y = probe_loc
</span><span>        </span><span style="color:#b48ead;">if </span><span>x &gt; x1 or y &lt; y0:
</span><span>            within_target = </span><span style="color:#96b5b4;">any</span><span>(x0 &lt;= x &lt;= x1 and
</span><span>                                y0 &lt;= y &lt;= y1
</span><span>                                </span><span style="color:#b48ead;">for </span><span>x, y </span><span style="color:#b48ead;">in </span><span>path)
</span><span>            </span><span style="color:#b48ead;">return </span><span>within_target, path
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">solver</span><span>(</span><span style="color:#bf616a;">x0</span><span>, </span><span style="color:#bf616a;">x1</span><span>, </span><span style="color:#bf616a;">y0</span><span>, </span><span style="color:#bf616a;">y1</span><span>):
</span><span>    mem = {(x, y): </span><span style="color:#bf616a;">simulate</span><span>(x0, x1, y0, y1, (x, y))
</span><span>           </span><span style="color:#b48ead;">for </span><span>x </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(-x1 - </span><span style="color:#d08770;">1</span><span>, x1 + </span><span style="color:#d08770;">1</span><span>)
</span><span>           </span><span style="color:#b48ead;">for </span><span>y </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(y0 - </span><span style="color:#d08770;">1</span><span>, -y0 + </span><span style="color:#d08770;">1</span><span>)}
</span><span>    </span><span style="color:#b48ead;">return </span><span>mem
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day17_1</span><span>(</span><span style="color:#bf616a;">x0</span><span>, </span><span style="color:#bf616a;">x1</span><span>, </span><span style="color:#bf616a;">y0</span><span>, </span><span style="color:#bf616a;">y1</span><span>):
</span><span>    mem = </span><span style="color:#bf616a;">solver</span><span>(x0, x1, y0, y1)
</span><span>    mem = {k: </span><span style="color:#96b5b4;">max</span><span>(elem[</span><span style="color:#d08770;">1</span><span>] </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span>v[</span><span style="color:#d08770;">1</span><span>])
</span><span>           </span><span style="color:#b48ead;">for </span><span>k, v </span><span style="color:#b48ead;">in </span><span>mem.</span><span style="color:#bf616a;">items</span><span>()
</span><span>           </span><span style="color:#b48ead;">if </span><span>v[</span><span style="color:#d08770;">0</span><span>]}
</span><span>    max_loc = </span><span style="color:#96b5b4;">max</span><span>(mem, </span><span style="color:#bf616a;">key</span><span>=mem.get)
</span><span>    </span><span style="color:#b48ead;">return </span><span>mem[max_loc]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day17_2</span><span>(</span><span style="color:#bf616a;">x0</span><span>, </span><span style="color:#bf616a;">x1</span><span>, </span><span style="color:#bf616a;">y0</span><span>, </span><span style="color:#bf616a;">y1</span><span>):
</span><span>    mem = </span><span style="color:#bf616a;">solver</span><span>(x0, x1, y0, y1)
</span><span>    mem = {k: v </span><span style="color:#b48ead;">for </span><span>k, v </span><span style="color:#b48ead;">in </span><span>mem.</span><span style="color:#bf616a;">items</span><span>() </span><span style="color:#b48ead;">if </span><span>v[</span><span style="color:#d08770;">0</span><span>]}
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(mem.</span><span style="color:#bf616a;">keys</span><span>())
</span><span>
</span><span>data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">17</span><span>,
</span><span>                    </span><span style="color:#bf616a;">parser</span><span>=</span><span style="color:#b48ead;">lambda </span><span style="color:#bf616a;">x</span><span>: re.</span><span style="color:#bf616a;">findall</span><span>(
</span><span>                        </span><span style="color:#b48ead;">r</span><span>&#39;</span><span style="color:#d08770;">.</span><span>*?</span><span style="color:#a3be8c;">x=(</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">)</span><span style="color:#d08770;">..</span><span style="color:#a3be8c;">(</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">), y=-(</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">)</span><span style="color:#d08770;">..</span><span style="color:#a3be8c;">-(</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">)</span><span>&#39;, x))
</span><span>x0, x1, y0, y1 = data[</span><span style="color:#d08770;">0</span><span>][</span><span style="color:#d08770;">0</span><span>]
</span><span>x0, x1, y0, y1 = </span><span style="color:#bf616a;">int</span><span>(x0), </span><span style="color:#bf616a;">int</span><span>(x1), -</span><span style="color:#bf616a;">int</span><span>(y0), -</span><span style="color:#bf616a;">int</span><span>(y1)
</span></code></pre>
<p>Using brute force to solve this problem.</p>
<h2 id="day-18-snailfish"><a href="http://adventofcode.com/2021/day/18">Day 18: Snailfish</a></h2>
<p>This is a special math.</p>
<ul>
<li>formal be like: [[1,9],[8,5]]</li>
<li>each formal must be reduced by the rule:
<ul>
<li>If any pair is nested inside four pairs, the leftmost such pair explodes</li>
<li>If any pair is nested inside four pairs, the leftmost such pair explodes</li>
<li>During reduction, at most one action applied</li>
<li>To explode a pair, the pair's left value is added to the first regular number to the left of the exploding pair (if any), and the pair's right value is added to the first regular number to the right of the exploding pair (if any)</li>
<li>To split a regular number, replace it with a pair; the left element of the pair should be the regular number divided by two and rounded down, while the right element of the pair should be the regular number divided by two and rounded up</li>
</ul>
</li>
<li>The magnitude of a pair is 3 times the magnitude of its left element plus 2 times the magnitude of its right element</li>
</ul>
<p>Part1 Add up all of the snailfish numbers from the homework assignment in the order they appear. What is the magnitude of the final sum?</p>
<p>Part2: The magnitude of a pair is 3 times the magnitude of its left element plus 2 times the magnitude of its right element?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_explode_parts</span><span>(</span><span style="color:#bf616a;">exp</span><span>):
</span><span>    depth = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>i, char </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(exp):
</span><span>        </span><span style="color:#b48ead;">if </span><span>char == &#39;</span><span style="color:#a3be8c;">[</span><span>&#39;:
</span><span>            depth += </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#b48ead;">elif </span><span>char == &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;:
</span><span>            depth -= </span><span style="color:#d08770;">1
</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>depth == </span><span style="color:#d08770;">5</span><span>:
</span><span>            </span><span style="color:#b48ead;">break
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>j, char </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(exp[i:]):
</span><span>        </span><span style="color:#b48ead;">if </span><span>char == &#39;</span><span style="color:#a3be8c;">]</span><span>&#39;:
</span><span>            </span><span style="color:#b48ead;">break
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>depth == </span><span style="color:#d08770;">5</span><span>:
</span><span>        </span><span style="color:#65737e;"># pair within four pairs, left part and right part
</span><span>        </span><span style="color:#b48ead;">return </span><span>exp[i:i+j+</span><span style="color:#d08770;">1</span><span>], exp[:i], exp[i+j+</span><span style="color:#d08770;">1</span><span>:]
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">None</span><span>, </span><span style="color:#d08770;">None</span><span>, </span><span style="color:#d08770;">None
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">explode</span><span>(</span><span style="color:#bf616a;">exp</span><span>):
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">add_left</span><span>(</span><span style="color:#bf616a;">m</span><span>):
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">str</span><span>(</span><span style="color:#bf616a;">int</span><span>(m.</span><span style="color:#bf616a;">group</span><span>(</span><span style="color:#d08770;">0</span><span>)) + left_num)
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">add_right</span><span>(</span><span style="color:#bf616a;">m</span><span>):
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">str</span><span>(</span><span style="color:#bf616a;">int</span><span>(m.</span><span style="color:#bf616a;">group</span><span>(</span><span style="color:#d08770;">0</span><span>)) + right_num)
</span><span>
</span><span>    exp = </span><span style="color:#bf616a;">str</span><span>(exp)
</span><span>    exp_four_pair, left_exp, right_exp = </span><span style="color:#bf616a;">gen_explode_parts</span><span>(exp)
</span><span>    </span><span style="color:#b48ead;">if </span><span>not exp_four_pair:
</span><span>        </span><span style="color:#b48ead;">return </span><span>exp
</span><span>
</span><span>    left_num, right_num = ast.</span><span style="color:#bf616a;">literal_eval</span><span>(exp_four_pair)
</span><span>    exp_left = re.</span><span style="color:#bf616a;">sub</span><span>(</span><span style="color:#b48ead;">r</span><span>&quot;</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">(</span><span style="color:#d08770;">?=\D</span><span>*</span><span style="color:#b48ead;">$</span><span style="color:#a3be8c;">)</span><span>&quot;, add_left, left_exp)
</span><span>    exp_right = re.</span><span style="color:#bf616a;">sub</span><span>(</span><span style="color:#b48ead;">r</span><span>&quot;</span><span style="color:#d08770;">\d</span><span>+&quot;, add_right, right_exp, </span><span style="color:#bf616a;">count</span><span>=</span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span>    final_exp = exp_left + &#39;</span><span style="color:#a3be8c;">0</span><span>&#39; + exp_right
</span><span>    </span><span style="color:#b48ead;">return </span><span>ast.</span><span style="color:#bf616a;">literal_eval</span><span>(final_exp)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">split</span><span>(</span><span style="color:#bf616a;">exp</span><span>):
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">subsplit</span><span>(</span><span style="color:#bf616a;">m</span><span>):
</span><span>        num = </span><span style="color:#bf616a;">int</span><span>(m.</span><span style="color:#bf616a;">group</span><span>(</span><span style="color:#d08770;">0</span><span>))
</span><span>        </span><span style="color:#b48ead;">return f</span><span>&quot;</span><span style="color:#a3be8c;">[</span><span>{math.</span><span style="color:#bf616a;">floor</span><span>(</span><span style="color:#bf616a;">int</span><span>(num) / </span><span style="color:#d08770;">2</span><span>)}</span><span style="color:#a3be8c;">,</span><span>{math.</span><span style="color:#bf616a;">ceil</span><span>(num / </span><span style="color:#d08770;">2</span><span>)}</span><span style="color:#a3be8c;">]</span><span>&quot;
</span><span>
</span><span>    exp = </span><span style="color:#bf616a;">str</span><span>(exp)
</span><span>    out = re.</span><span style="color:#bf616a;">sub</span><span>(</span><span style="color:#b48ead;">r</span><span>&quot;</span><span style="color:#d08770;">\d</span><span>{2}&quot;, subsplit, exp, </span><span style="color:#bf616a;">count</span><span>=</span><span style="color:#d08770;">1</span><span>)
</span><span>    </span><span style="color:#b48ead;">return </span><span>ast.</span><span style="color:#bf616a;">literal_eval</span><span>(out)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">add</span><span>(</span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span>[a, b]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">reduce</span><span>(</span><span style="color:#bf616a;">exp</span><span>):
</span><span>    out = </span><span style="color:#bf616a;">explode</span><span>(exp)
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">str</span><span>(out) == </span><span style="color:#bf616a;">str</span><span>(exp):
</span><span>        </span><span style="color:#65737e;"># explode until there is no explode and then split
</span><span>        out = </span><span style="color:#bf616a;">split</span><span>(exp)
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#bf616a;">str</span><span>(out) == </span><span style="color:#bf616a;">str</span><span>(exp):
</span><span>        </span><span style="color:#b48ead;">return </span><span>exp
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">reduce</span><span>(out)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">calc_magnitude</span><span>(</span><span style="color:#bf616a;">exp</span><span>):
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">magnitude</span><span>(</span><span style="color:#bf616a;">m</span><span>):
</span><span>        a = ast.</span><span style="color:#bf616a;">literal_eval</span><span>(m.</span><span style="color:#bf616a;">group</span><span>(</span><span style="color:#d08770;">0</span><span>))
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">str</span><span>(a[</span><span style="color:#d08770;">0</span><span>] * </span><span style="color:#d08770;">3 </span><span>+ a[</span><span style="color:#d08770;">1</span><span>] * </span><span style="color:#d08770;">2</span><span>)
</span><span>
</span><span>    exp = </span><span style="color:#bf616a;">str</span><span>(exp)
</span><span>    out = re.</span><span style="color:#bf616a;">sub</span><span>(</span><span style="color:#b48ead;">r</span><span>&#39;</span><span style="color:#96b5b4;">\[</span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#a3be8c;">, </span><span style="color:#d08770;">\d</span><span>+</span><span style="color:#96b5b4;">\]</span><span>&#39;, magnitude, exp)
</span><span>    out = ast.</span><span style="color:#bf616a;">literal_eval</span><span>(out)
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">isinstance</span><span>(out, list):
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">calc_magnitude</span><span>(out)
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span>out
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day18_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    data = copy.</span><span style="color:#bf616a;">deepcopy</span><span>(data)
</span><span>    running = data.</span><span style="color:#bf616a;">pop</span><span>(</span><span style="color:#d08770;">0</span><span>)
</span><span>    </span><span style="color:#b48ead;">while </span><span>data:
</span><span>        next_add = data.</span><span style="color:#bf616a;">pop</span><span>(</span><span style="color:#d08770;">0</span><span>)
</span><span>        running = </span><span style="color:#bf616a;">add</span><span>(running, next_add)
</span><span>        running = </span><span style="color:#96b5b4;">reduce</span><span>(running)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">calc_magnitude</span><span>(running)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day18_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    scores = []
</span><span>    </span><span style="color:#b48ead;">for </span><span>elem </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">combinations</span><span>(data, </span><span style="color:#d08770;">2</span><span>):
</span><span>        left, right = elem
</span><span>        score1 = </span><span style="color:#bf616a;">calc_magnitude</span><span>(</span><span style="color:#96b5b4;">reduce</span><span>(</span><span style="color:#bf616a;">add</span><span>(left, right)))
</span><span>        score2 = </span><span style="color:#bf616a;">calc_magnitude</span><span>(</span><span style="color:#96b5b4;">reduce</span><span>(</span><span style="color:#bf616a;">add</span><span>(right, left)))
</span><span>        scores.</span><span style="color:#bf616a;">append</span><span>(score1)
</span><span>        scores.</span><span style="color:#bf616a;">append</span><span>(score2)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">max</span><span>(scores)
</span></code></pre>
<p>At first, I use nested list to represent the formula. But after some try, I can't found a clear way to explode(split works ok). Almost giving up, then the <a href="https://www.reddit.com/r/adventofcode">Aoc Subreddit</a> helped me, I see someone use tree structure to represent the formula and other people use string to represent the formula. String? Really? When I see the <a href="https://topaz.github.io/paste/#XQAAAQDMCwAAAAAAAAA0m0pnuFI8c+fPp4HB1KcQKnBu+WCk1EVjq93Wu6MmEjgQZO0R0cACtyObjsZhwTf3oOb2ujEhwIrJbER41xleoj0A+3ovoDJWPmAj5gWoFfXX7qRpA49tiHhhxInXZ0x0+oBycxaAp7uOKcRuAT1PpSNaxTT4WQ+cZ6QzAKIaFJoRIvtVJPExXtg9l2G7ugtsSdLRCFtYOSLiuFwiKWw/1/2ddZ8Yk3tgNCSpfrsN9JzeJfJTLv5qM8GPToy1St2XxPrSHQPsqrI4HRKwslnQXHeVrTsSZsVOMXrEsc165FW1FQQqQqviOyw6mchlPM69/fmhh2h24RIXbOg7XHOifNyePqZA8pe5KlbNtEdgG0qhW/1DV3ZFL6Ia1nW4kgaej0OtYjGnyfZOki3E+Ik3/ZZ89mhZdsqkhtVuHNn7MqPq+KEtus2jmNwc3qMFt34fCIZykq0KHdqqQZIMmVwlja90EFoSGSmJTilsomnK6540XulRnJcVc436LIMdDnjXR5OI29V3DOxALI/zoVKtIlLBPb9R/heQOOloIL0wSaQHOKTv7vSTXrSnSaDw0/3Xs9Dz1MyT/+aEw8kLU9fOgXYJn1jgq862gXI8VXnX2toEgOLY+uWFtiE92jqzpnMSI/g7ndAcCmu5nGDcSbRa8tkaXU/TizR7t1zEruemwrQceymySnPVTyeBvaiFAcrnifZeJ4fWnjv+jTQx9ugpcV3BiEJCKKrK4f5sy+lqTUXoWzKqCBxFi++UzpaXjldOk0B8YsZxgk5N/FzoCr2gbKNJ0lcfxvFKYK3UNGa+FTcI4egAvJ7Q2p+ZDE+LXBC2XmugmS7xpOqHpde5unXSINM/MhPda1T+BopN4PFIJ1lCHi1wf6Wmeoa7otoabg7UzMuajVL7a2UE7FnrPwPbqMZWERofVM92HBTQGjahBFipL1700/DzshTrQe8x4aq5qEvfVdLXPOgn79pL/UOAmEoPJijQDzsuPynLtFksYx/cno5rsAnWNjOOvVXoun4HAC5Ky0jofhUZ8IMIcxoZhO+9FDPHE3tzJXhes+xHbf5O0bZ6ayv6Lcam0dHg8M6aQdFjB4Inzk4IzYPSksGiczXmvRBRN1WjNiHTGhxZ2E10zjXsfjr+j2cl7QGAmOHRHgotpoZwyEao+Olo9mKtrCWii6hPP1lpD3lN5tiisf9+N5KApOrVRHB9EUvVsoqqdcCnrhjgrBEgpnsKs11rSQM9rNdi8jcPsF62UEMwX6T770iWE+1dVDZPGqVunilny5ARwU7krIt/ghYWa1RZH/i5PXVgurYoFTbH6+Xq8EWjbsGfEVanLk51XvZgu9A61bjgnqRYvGCB/DujaaECyGdbyz+zsNlv4L91xBInvOtgO9z25wKuvDezgBegaW66vajmpcQU//qqsm0=">code</a>, I know string will work better. So I change the solution to use string. Amazing!</p>
<h2 id="day-19-beacon-scanner"><a href="https://adventofcode.com/2021/day/19">Day 19: Beacon Scanner</a></h2>
<ul>
<li>scanners report some beacon and the scanner may be rotated by 90 degree in xyz axes and facing positive or negative(24 different orientations).</li>
<li>two scanners near overlapped at least 12 beacons.</li>
</ul>
<p>Part1: Assemble the full map of beacons. How many beacons are there?</p>
<p>Part2: Assemble the full map of beacons. How many beacons are there?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Scanner</span><span style="color:#eff1f5;">:
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#96b5b4;">__init__</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">beacons</span><span>) -&gt; </span><span style="color:#d08770;">None</span><span>:
</span><span>        </span><span style="color:#bf616a;">self</span><span>.beacons = beacons
</span><span>        </span><span style="color:#bf616a;">self</span><span>.final = </span><span style="color:#bf616a;">set</span><span>()
</span><span>        </span><span style="color:#bf616a;">self</span><span>.offset = </span><span style="color:#d08770;">None
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">xy_rotation</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (x, y, z)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (y, -x, z)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (-x, -y, z)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (-y, x, z)
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">yz_rotation</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (x, y, z)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (x, z, -y)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (x, -y, -z)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (x, -z, y)
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">xz_rotation</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (x, y, z)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (z, y, -x)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (-x, y, -z)
</span><span>        </span><span style="color:#b48ead;">yield lambda </span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>, </span><span style="color:#bf616a;">z</span><span>: (-z, y, x)
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">rotations</span><span>(</span><span style="color:#bf616a;">self</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>xy </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">xy_rotation</span><span>():
</span><span>            </span><span style="color:#b48ead;">for </span><span>yz </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">yz_rotation</span><span>():
</span><span>                </span><span style="color:#b48ead;">for </span><span>xz </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">self</span><span>.</span><span style="color:#bf616a;">xz_rotation</span><span>():
</span><span>                    rotated_beacons = </span><span style="color:#bf616a;">set</span><span>()
</span><span>                    </span><span style="color:#b48ead;">for </span><span>beacon </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">self</span><span>.beacons:
</span><span>                        rotated_beacons.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#bf616a;">xz</span><span>(*</span><span style="color:#bf616a;">yz</span><span>(*</span><span style="color:#bf616a;">xy</span><span>(*beacon))))
</span><span>                    </span><span style="color:#b48ead;">yield </span><span>rotated_beacons
</span><span>
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">translate</span><span>(</span><span style="color:#bf616a;">self</span><span>, </span><span style="color:#bf616a;">beacons</span><span>, </span><span style="color:#bf616a;">offset</span><span>):
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">set</span><span>([(beacon[</span><span style="color:#d08770;">0</span><span>] + offset[</span><span style="color:#d08770;">0</span><span>],
</span><span>                    beacon[</span><span style="color:#d08770;">1</span><span>] + offset[</span><span style="color:#d08770;">1</span><span>],
</span><span>                    beacon[</span><span style="color:#d08770;">2</span><span>] + offset[</span><span style="color:#d08770;">2</span><span>]) </span><span style="color:#b48ead;">for </span><span>beacon </span><span style="color:#b48ead;">in </span><span>beacons])
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">solve</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    scanners = []
</span><span>    </span><span style="color:#b48ead;">for </span><span>part </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        beacons = </span><span style="color:#bf616a;">set</span><span>()
</span><span>        </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>part.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;):
</span><span>            </span><span style="color:#b48ead;">if </span><span>not line.</span><span style="color:#bf616a;">startswith</span><span>(&#39;</span><span style="color:#a3be8c;">--</span><span>&#39;):
</span><span>                loc = [</span><span style="color:#bf616a;">int</span><span>(num) </span><span style="color:#b48ead;">for </span><span>num </span><span style="color:#b48ead;">in </span><span>line.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;)]
</span><span>                beacons.</span><span style="color:#bf616a;">add</span><span>(</span><span style="color:#bf616a;">tuple</span><span>(loc))
</span><span>        scanners.</span><span style="color:#bf616a;">append</span><span>(</span><span style="color:#bf616a;">Scanner</span><span>(beacons))
</span><span>
</span><span>    scanners[</span><span style="color:#d08770;">0</span><span>].final = scanners[</span><span style="color:#d08770;">0</span><span>].beacons
</span><span>    scanners[</span><span style="color:#d08770;">0</span><span>].offset = (</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>)
</span><span>
</span><span>    fixed_scanner = </span><span style="color:#bf616a;">set</span><span>()
</span><span>    fixed_scanner.</span><span style="color:#bf616a;">add</span><span>(scanners[</span><span style="color:#d08770;">0</span><span>])
</span><span>
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#96b5b4;">len</span><span>(fixed_scanner) &lt; </span><span style="color:#96b5b4;">len</span><span>(scanners):
</span><span>        </span><span style="color:#b48ead;">for </span><span>scanner </span><span style="color:#b48ead;">in </span><span>scanners:
</span><span>            </span><span style="color:#b48ead;">if </span><span>scanner in fixed_scanner:
</span><span>                </span><span style="color:#b48ead;">continue
</span><span>
</span><span>            fixed_beacons = </span><span style="color:#bf616a;">set</span><span>().</span><span style="color:#bf616a;">union</span><span>(*[s.final </span><span style="color:#b48ead;">for </span><span>s </span><span style="color:#b48ead;">in </span><span>fixed_scanner])
</span><span>            </span><span style="color:#b48ead;">for </span><span>r </span><span style="color:#b48ead;">in </span><span>scanner.</span><span style="color:#bf616a;">rotations</span><span>():
</span><span>                </span><span style="color:#b48ead;">for </span><span>floc </span><span style="color:#b48ead;">in </span><span>fixed_beacons:
</span><span>                    </span><span style="color:#b48ead;">for </span><span>loc </span><span style="color:#b48ead;">in </span><span>r:
</span><span>                        offset = (floc[</span><span style="color:#d08770;">0</span><span>] - loc[</span><span style="color:#d08770;">0</span><span>],
</span><span>                                  floc[</span><span style="color:#d08770;">1</span><span>] - loc[</span><span style="color:#d08770;">1</span><span>],
</span><span>                                  floc[</span><span style="color:#d08770;">2</span><span>] - loc[</span><span style="color:#d08770;">2</span><span>])
</span><span>                        shifted = scanner.</span><span style="color:#bf616a;">translate</span><span>(r, offset)
</span><span>                        </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">len</span><span>(shifted.</span><span style="color:#bf616a;">intersection</span><span>(fixed_beacons)) &gt;= </span><span style="color:#d08770;">12</span><span>:
</span><span>                            scanner.final = shifted
</span><span>                            scanner.offset = offset
</span><span>                            fixed_scanner.</span><span style="color:#bf616a;">add</span><span>(scanner)
</span><span>                            </span><span style="color:#b48ead;">break
</span><span>    </span><span style="color:#b48ead;">return </span><span>fixed_scanner, scanners
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day19_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    fixed_scanner, </span><span style="color:#bf616a;">_ </span><span>= </span><span style="color:#bf616a;">solve</span><span>(data)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>(</span><span style="color:#bf616a;">set</span><span>().</span><span style="color:#bf616a;">union</span><span>(*[s.final </span><span style="color:#b48ead;">for </span><span>s </span><span style="color:#b48ead;">in </span><span>fixed_scanner]))
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">manhattan_distance</span><span>(</span><span style="color:#bf616a;">s1</span><span>, </span><span style="color:#bf616a;">s2</span><span>):
</span><span>    loc1 = s1.offset
</span><span>    loc2 = s2.offset
</span><span>    </span><span style="color:#b48ead;">return </span><span>(</span><span style="color:#96b5b4;">abs</span><span>(loc1[</span><span style="color:#d08770;">0</span><span>] - loc2[</span><span style="color:#d08770;">0</span><span>]) +
</span><span>            </span><span style="color:#96b5b4;">abs</span><span>(loc1[</span><span style="color:#d08770;">1</span><span>] - loc2[</span><span style="color:#d08770;">1</span><span>]) +
</span><span>            </span><span style="color:#96b5b4;">abs</span><span>(loc1[</span><span style="color:#d08770;">2</span><span>] - loc2[</span><span style="color:#d08770;">2</span><span>]))
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day19_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    </span><span style="color:#bf616a;">_</span><span>, scanners = </span><span style="color:#bf616a;">solve</span><span>(data)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">max</span><span>(</span><span style="color:#bf616a;">manhattan_distance</span><span>(s1, s2)
</span><span>               </span><span style="color:#b48ead;">for </span><span>s1, s2 </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">combinations</span><span>(scanners, </span><span style="color:#d08770;">2</span><span>))
</span></code></pre>
<p>TodayI cheated and not found the solution by myself, the origin code is <a href="https://github.com/JamesMCo/Advent-Of-Code/tree/master/2021/19">here</a>. I just understand the logic and rewrite some code.</p>
<p>Honesty is the best policy.</p>
<h2 id="day-20-trench-map"><a href="https://adventofcode.com/2021/day/20">Day 20: Trench Map</a></h2>
<p>You get a 2D image(# represent light, . represent dark) and an algorithm(a seqence contains # and .) to enhence the image.</p>
<p>With the enhence rule, the image(infinite) will change the light and dark pixel.</p>
<ul>
<li>the pixel beyound the image will be initialized as dark(represent by .)</li>
<li>to determine the pixel after enhencing, combine the nine neighbors(from left-top to right-down, including itself) and convert # to 1 and . to 0</li>
<li>then convert the binary number to decimal number(such as '000100010' to 34)</li>
<li>use the decimal number to determine the pixel after enhencing(index of the algorithm)</li>
<li>all pixel change simultaneously</li>
</ul>
<p>Part1: Start with the original input image and apply the image enhancement algorithm twice, being careful to account for the infinite size of the images. How many pixels are lit in the resulting image?</p>
<p>Part2: Start again with the original input image and apply the image enhancement algorithm 50 times. How many pixels are lit in the resulting image?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_data</span><span>():
</span><span>    data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">20</span><span>, </span><span style="color:#bf616a;">parser</span><span>=str, </span><span style="color:#bf616a;">sep</span><span>=&#39;</span><span style="color:#96b5b4;">\n\n</span><span>&#39;)
</span><span>    algorithm = data[</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#bf616a;">replace</span><span>(&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;, &#39;&#39;)
</span><span>    image = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>y, line </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(data[</span><span style="color:#d08770;">1</span><span>].</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#96b5b4;">\n</span><span>&#39;)):
</span><span>        </span><span style="color:#b48ead;">for </span><span>x, char </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(line):
</span><span>            image[(x, y)] = char
</span><span>    </span><span style="color:#b48ead;">return </span><span>algorithm, image
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">nine_locs</span><span>(</span><span style="color:#bf616a;">x</span><span>, </span><span style="color:#bf616a;">y</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span>[(x-</span><span style="color:#d08770;">1</span><span>, y-</span><span style="color:#d08770;">1</span><span>), (x, y-</span><span style="color:#d08770;">1</span><span>), (x+</span><span style="color:#d08770;">1</span><span>, y-</span><span style="color:#d08770;">1</span><span>),
</span><span>            (x-</span><span style="color:#d08770;">1</span><span>, y), (x, y), (x+</span><span style="color:#d08770;">1</span><span>, y),
</span><span>            (x-</span><span style="color:#d08770;">1</span><span>, y+</span><span style="color:#d08770;">1</span><span>), (x, y+</span><span style="color:#d08770;">1</span><span>), (x+</span><span style="color:#d08770;">1</span><span>, y+</span><span style="color:#d08770;">1</span><span>)]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">translate</span><span>(</span><span style="color:#bf616a;">loc</span><span>, </span><span style="color:#bf616a;">image</span><span>, </span><span style="color:#bf616a;">algorithm</span><span>, </span><span style="color:#bf616a;">step</span><span>):
</span><span>    code = &#39;&#39;
</span><span>    </span><span style="color:#b48ead;">for </span><span>nloc </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">nine_locs</span><span>(*loc):
</span><span>        </span><span style="color:#b48ead;">if </span><span>step % </span><span style="color:#d08770;">2 </span><span>== </span><span style="color:#d08770;">0 </span><span>and algorithm[</span><span style="color:#d08770;">0</span><span>] == &#39;</span><span style="color:#a3be8c;">#</span><span>&#39;:
</span><span>            </span><span style="color:#b48ead;">if </span><span>nloc in image:
</span><span>                code += &#39;</span><span style="color:#a3be8c;">1</span><span>&#39; </span><span style="color:#b48ead;">if </span><span>image.</span><span style="color:#bf616a;">get</span><span>(nloc) == &#39;</span><span style="color:#a3be8c;">#</span><span>&#39; </span><span style="color:#b48ead;">else </span><span>&#39;</span><span style="color:#a3be8c;">0</span><span>&#39;
</span><span>            </span><span style="color:#b48ead;">else</span><span>:
</span><span>                code += &#39;</span><span style="color:#a3be8c;">1</span><span>&#39;
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            code += &#39;</span><span style="color:#a3be8c;">1</span><span>&#39; </span><span style="color:#b48ead;">if </span><span>image.</span><span style="color:#bf616a;">get</span><span>(nloc) == &#39;</span><span style="color:#a3be8c;">#</span><span>&#39; </span><span style="color:#b48ead;">else </span><span>&#39;</span><span style="color:#a3be8c;">0</span><span>&#39;
</span><span>    index = </span><span style="color:#bf616a;">int</span><span>(code, </span><span style="color:#d08770;">2</span><span>)
</span><span>    </span><span style="color:#b48ead;">return </span><span>algorithm[index]
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">simulate</span><span>(</span><span style="color:#bf616a;">image</span><span>, </span><span style="color:#bf616a;">algorithm</span><span>, </span><span style="color:#bf616a;">step</span><span>):
</span><span>    new_image = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    locs_to_explore = </span><span style="color:#bf616a;">set</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc </span><span style="color:#b48ead;">in </span><span>image.</span><span style="color:#bf616a;">keys</span><span>():
</span><span>        </span><span style="color:#b48ead;">for </span><span>near_loc </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">nine_locs</span><span>(*loc):
</span><span>            locs_to_explore.</span><span style="color:#bf616a;">add</span><span>(near_loc)
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc </span><span style="color:#b48ead;">in </span><span>locs_to_explore:
</span><span>        new_image[loc] = </span><span style="color:#bf616a;">translate</span><span>(loc, image, algorithm, step)
</span><span>    </span><span style="color:#b48ead;">return </span><span>new_image
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day20_1</span><span>(</span><span style="color:#bf616a;">algorithm</span><span>, </span><span style="color:#bf616a;">image</span><span>):
</span><span>    </span><span style="color:#b48ead;">for </span><span>step </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">3</span><span>):
</span><span>        image = </span><span style="color:#bf616a;">simulate</span><span>(image, algorithm, step)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">list</span><span>(image.</span><span style="color:#bf616a;">values</span><span>()).</span><span style="color:#bf616a;">count</span><span>(&#39;</span><span style="color:#a3be8c;">#</span><span>&#39;)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day20_2</span><span>(</span><span style="color:#bf616a;">algorithm</span><span>, </span><span style="color:#bf616a;">image</span><span>):
</span><span>    </span><span style="color:#b48ead;">for </span><span>step </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">51</span><span>):
</span><span>        image = </span><span style="color:#bf616a;">simulate</span><span>(image, algorithm, step)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">list</span><span>(image.</span><span style="color:#bf616a;">values</span><span>()).</span><span style="color:#bf616a;">count</span><span>(&#39;</span><span style="color:#a3be8c;">#</span><span>&#39;)
</span></code></pre>
<p>The tricky part is the algorithm start with a # and end with a ., which means the infinate pixel far away from the origin image will blink every(2 enhence steps).</p>
<p>The 1st step, the nine neighbors of the pixel are all ., so the binary number will be 000000000, which will change the pixel to #.</p>
<p>The 2nd step, the nine neighbors of the pixel are all #, so the binary number will be 111111111, which will change the pixel to ".".</p>
<p>Didn't realize that at first, so spending a lot of time to debug. Auctally, it's easy if you find out the above tricky part.</p>
<h2 id="day-21-dirac-dice"><a href="https://adventofcode.com/2021/day/21">Day 21: Dirac Dice</a></h2>
<p>Two player play a dirac dice game.</p>
<ul>
<li>each player roll a dice three times</li>
<li>the player move(around 1 to 10) follow the dice number(if greater than 10, then move to 1)</li>
<li>with each move, the player's score increase by the position of the player(after move)</li>
</ul>
<p>Part1:</p>
<ul>
<li>the dice is deterministic with 100-sided(meaning the dice rolls 1, 2...100...1)</li>
<li>the player who's score is greater than 1000 wins</li>
<li>question: what do you get if you multiply the score of the losing player by the number of times the die was rolled during the game?</li>
</ul>
<p>Part2:</p>
<ul>
<li>the dice is quantum, when you roll it, the universe splits into 3 copys: one where the outcome of the roll is 1, one where the outcome of the roll is 2, and one where the outcome of the roll is 3.</li>
<li>the player who's score is greater than 24 wins</li>
<li>question: find the player that wins in more universes; in how many universes does that player win?</li>
</ul>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">play_game</span><span>(</span><span style="color:#bf616a;">p_pos</span><span>, </span><span style="color:#bf616a;">p_score</span><span>, </span><span style="color:#bf616a;">dice_pos</span><span>):
</span><span>    move_pos = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">3</span><span>):
</span><span>        </span><span style="color:#b48ead;">if </span><span>(dice_pos + i) &lt;= </span><span style="color:#d08770;">100</span><span>:
</span><span>            move_pos += (dice_pos + i)
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            move_pos += (dice_pos + i) - </span><span style="color:#d08770;">100
</span><span>
</span><span>    </span><span style="color:#b48ead;">if </span><span>(p_pos + move_pos) % </span><span style="color:#d08770;">10 </span><span>== </span><span style="color:#d08770;">0</span><span>:
</span><span>        p_pos = </span><span style="color:#d08770;">10
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        p_pos = (p_pos + move_pos) % </span><span style="color:#d08770;">10
</span><span>
</span><span>    p_score += p_pos
</span><span>    dice_pos = dice_pos + </span><span style="color:#d08770;">3 </span><span style="color:#b48ead;">if </span><span>(dice_pos + </span><span style="color:#d08770;">3</span><span>) &lt;= </span><span style="color:#d08770;">100 </span><span style="color:#b48ead;">else </span><span>dice_pos + </span><span style="color:#d08770;">3 </span><span>- </span><span style="color:#d08770;">100
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>p_pos, p_score, dice_pos
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day21_1</span><span>():
</span><span>    p1_pos, p2_pos = (</span><span style="color:#d08770;">7</span><span>, </span><span style="color:#d08770;">1</span><span>)
</span><span>    p1_score, p2_score = </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0
</span><span>    dice_pos, dice_rolls = </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>        p1_pos, p1_score, dice_pos = </span><span style="color:#bf616a;">play_game</span><span>(p1_pos, p1_score, dice_pos)
</span><span>        dice_rolls += </span><span style="color:#d08770;">3
</span><span>        </span><span style="color:#b48ead;">if </span><span>p1_score &gt;= </span><span style="color:#d08770;">1000</span><span>:
</span><span>            </span><span style="color:#b48ead;">return </span><span>p2_score * dice_rolls
</span><span>
</span><span>        p2_pos, p2_score, dice_pos = </span><span style="color:#bf616a;">play_game</span><span>(p2_pos, p2_score, dice_pos)
</span><span>        dice_rolls += </span><span style="color:#d08770;">3
</span><span>        </span><span style="color:#b48ead;">if </span><span>p2_score &gt;= </span><span style="color:#d08770;">1000</span><span>:
</span><span>            </span><span style="color:#b48ead;">return </span><span>p1_score * dice_rolls
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">play_once</span><span>(</span><span style="color:#bf616a;">p_score</span><span>, </span><span style="color:#bf616a;">p_pos</span><span>, </span><span style="color:#bf616a;">rolls</span><span>):
</span><span>    </span><span style="color:#b48ead;">if </span><span>(p_pos + </span><span style="color:#96b5b4;">sum</span><span>(rolls)) % </span><span style="color:#d08770;">10 </span><span>== </span><span style="color:#d08770;">0</span><span>:
</span><span>        p_pos = </span><span style="color:#d08770;">10
</span><span>    </span><span style="color:#b48ead;">else</span><span>:
</span><span>        p_pos = (p_pos + </span><span style="color:#96b5b4;">sum</span><span>(rolls)) % </span><span style="color:#d08770;">10
</span><span>    p_score += p_pos
</span><span>    </span><span style="color:#b48ead;">return </span><span>p_pos, p_score
</span><span>
</span><span>
</span><span>@</span><span style="color:#bf616a;">lru_cache</span><span>(</span><span style="color:#bf616a;">maxsize</span><span>=</span><span style="color:#d08770;">None</span><span>)
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">count_wins</span><span>(</span><span style="color:#bf616a;">current_player</span><span>, </span><span style="color:#bf616a;">p1_pos</span><span>, </span><span style="color:#bf616a;">p1_score</span><span>, </span><span style="color:#bf616a;">p2_pos</span><span>, </span><span style="color:#bf616a;">p2_score</span><span>):
</span><span>    </span><span style="color:#b48ead;">if </span><span>p1_score &gt;= </span><span style="color:#d08770;">21</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">if </span><span>p2_score &gt;= </span><span style="color:#d08770;">21</span><span>:
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">1
</span><span>
</span><span>    wins = [</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0</span><span>]
</span><span>    </span><span style="color:#b48ead;">for </span><span>rolls </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">product</span><span>(</span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">4</span><span>), </span><span style="color:#bf616a;">repeat</span><span>=</span><span style="color:#d08770;">3</span><span>):
</span><span>        </span><span style="color:#b48ead;">if </span><span>current_player == </span><span style="color:#d08770;">0</span><span>:
</span><span>            new_pos, new_score = </span><span style="color:#bf616a;">play_once</span><span>(p1_score, p1_pos, rolls)
</span><span>            win0, win1 = </span><span style="color:#bf616a;">count_wins</span><span>(</span><span style="color:#d08770;">1</span><span>, new_pos, new_score, p2_pos, p2_score)
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            new_pos, new_score = </span><span style="color:#bf616a;">play_once</span><span>(p2_score, p2_pos, rolls)
</span><span>            win0, win1 = </span><span style="color:#bf616a;">count_wins</span><span>(</span><span style="color:#d08770;">0</span><span>, p1_pos, p1_score, new_pos, new_score)
</span><span>        wins[</span><span style="color:#d08770;">0</span><span>] += win0
</span><span>        wins[</span><span style="color:#d08770;">1</span><span>] += win1
</span><span>    </span><span style="color:#b48ead;">return </span><span>wins
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day21_2</span><span>():
</span><span>    p1_pos, p2_pos = (</span><span style="color:#d08770;">7</span><span>, </span><span style="color:#d08770;">1</span><span>)
</span><span>    p1_score, p2_score = </span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">0
</span><span>    wins = </span><span style="color:#bf616a;">count_wins</span><span>(</span><span style="color:#d08770;">0</span><span>, p1_pos, p1_score, p2_pos, p2_score)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">max</span><span>(wins)
</span></code></pre>
<p>Part one is easy, just follow the rules. Part two is kind of hard to code. I finally refrenced the solution from reddit post.</p>
<h2 id="day-22-reactor-reboot"><a href="https://adventofcode.com/2021/day/22">Day 22: Reactor Reboot</a></h2>
<p>The reboot process is followed by steps to turn on or turn off the grid(like: on x=11..13,y=11..13,z=11..13, off x=9..11,y=9..11,z=9..11).</p>
<p>Part1: execute the reboot steps. Afterward, considering only cubes in the region x=-50..50,y=-50..50,z=-50..50, how many cubes are on?</p>
<p>Part2: Starting again with all cubes off, execute all reboot steps. Afterward, considering all cubes, how many cubes are on?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">parse_line</span><span>(</span><span style="color:#bf616a;">line</span><span>):
</span><span>    </span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">parse_loc</span><span>(</span><span style="color:#bf616a;">line</span><span>):
</span><span>        line_min, line_max = line[</span><span style="color:#d08770;">2</span><span>:].</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;">..</span><span>&#39;)
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">int</span><span>(line_min), </span><span style="color:#bf616a;">int</span><span>(line_max)
</span><span>
</span><span>    action, cubes = line.</span><span style="color:#bf616a;">split</span><span>(&#39; &#39;)
</span><span>    x, y, z = cubes.</span><span style="color:#bf616a;">split</span><span>(&#39;</span><span style="color:#a3be8c;">,</span><span>&#39;)
</span><span>    x_min, x_max = </span><span style="color:#bf616a;">parse_loc</span><span>(x)
</span><span>    y_min, y_max = </span><span style="color:#bf616a;">parse_loc</span><span>(y)
</span><span>    z_min, z_max = </span><span style="color:#bf616a;">parse_loc</span><span>(z)
</span><span>    </span><span style="color:#b48ead;">return </span><span>(action, x_min, x_max, y_min, y_max, z_min, z_max)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day22_1</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    down_limit = -</span><span style="color:#d08770;">50
</span><span>    up_limit = </span><span style="color:#d08770;">50
</span><span>    system = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        action, x_min, x_max, y_min, y_max, z_min, z_max = line
</span><span>        </span><span style="color:#b48ead;">if </span><span>(x_min &gt;= up_limit or x_max &lt;= down_limit or
</span><span>           y_min &gt;= up_limit or y_max &lt;= down_limit or
</span><span>           z_min &gt;= up_limit or z_max &lt;= down_limit):
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        </span><span style="color:#b48ead;">for </span><span>x </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(x_min, x_max + </span><span style="color:#d08770;">1</span><span>):
</span><span>            </span><span style="color:#b48ead;">for </span><span>y </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(y_min, y_max + </span><span style="color:#d08770;">1</span><span>):
</span><span>                </span><span style="color:#b48ead;">for </span><span>z </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(z_min, z_max + </span><span style="color:#d08770;">1</span><span>):
</span><span>                    system[(x, y, z)] = action
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">len</span><span>([k </span><span style="color:#b48ead;">for </span><span>k, v </span><span style="color:#b48ead;">in </span><span>system.</span><span style="color:#bf616a;">items</span><span>() </span><span style="color:#b48ead;">if </span><span>v == &#39;</span><span style="color:#a3be8c;">on</span><span>&#39;])
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">get_diff_cubes</span><span>(</span><span style="color:#bf616a;">cube_light</span><span>, </span><span style="color:#bf616a;">other_cub</span><span>):
</span><span>    x0, x1, y0, y1, z0, z1 = cube_light
</span><span>    x3, x4, y3, y4, z3, z4 = other_cub
</span><span>    </span><span style="color:#b48ead;">if </span><span>(x0 &gt; x4 or x1 &lt; x3 or y0 &gt; y4 or y1 &lt; y3 or z0 &gt; z4 or z1 &lt; z3):
</span><span>        </span><span style="color:#65737e;"># no overlap
</span><span>        </span><span style="color:#b48ead;">return </span><span>[(x0, x1, y0, y1, z0, z1)]
</span><span>    sub_cubes = []
</span><span>    left_x = (x0, </span><span style="color:#96b5b4;">max</span><span>(x0, x3) - </span><span style="color:#d08770;">1</span><span>)
</span><span>    mid_x = (</span><span style="color:#96b5b4;">max</span><span>(x0, x3), </span><span style="color:#96b5b4;">min</span><span>(x1, x4))
</span><span>    right_x = (</span><span style="color:#96b5b4;">min</span><span>(x1, x4) + </span><span style="color:#d08770;">1</span><span>, x1)
</span><span>
</span><span>    left_y = (y0, </span><span style="color:#96b5b4;">max</span><span>(y0, y3) - </span><span style="color:#d08770;">1</span><span>)
</span><span>    mid_y = (</span><span style="color:#96b5b4;">max</span><span>(y0, y3), </span><span style="color:#96b5b4;">min</span><span>(y1, y4))
</span><span>    right_y = (</span><span style="color:#96b5b4;">min</span><span>(y1, y4) + </span><span style="color:#d08770;">1</span><span>, y1)
</span><span>
</span><span>    left_z = (z0, </span><span style="color:#96b5b4;">max</span><span>(z0, z3) - </span><span style="color:#d08770;">1</span><span>)
</span><span>    mid_z = (</span><span style="color:#96b5b4;">max</span><span>(z0, z3), </span><span style="color:#96b5b4;">min</span><span>(z1, z4))
</span><span>    right_z = (</span><span style="color:#96b5b4;">min</span><span>(z1, z4) + </span><span style="color:#d08770;">1</span><span>, z1)
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>x, y, z </span><span style="color:#b48ead;">in </span><span style="color:#bf616a;">product</span><span>([left_x, mid_x, right_x],
</span><span>                           [left_y, mid_y, right_y],
</span><span>                           [left_z, mid_z, right_z]):
</span><span>        </span><span style="color:#b48ead;">if </span><span>x == mid_x and y == mid_y and z == mid_z:
</span><span>            </span><span style="color:#65737e;"># skip middle cube(overlap with other cube)
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        </span><span style="color:#b48ead;">elif </span><span>x[</span><span style="color:#d08770;">0</span><span>] &lt;= x[</span><span style="color:#d08770;">1</span><span>] and y[</span><span style="color:#d08770;">0</span><span>] &lt;= y[</span><span style="color:#d08770;">1</span><span>] and z[</span><span style="color:#d08770;">0</span><span>] &lt;= z[</span><span style="color:#d08770;">1</span><span>]:
</span><span>            </span><span style="color:#65737e;"># cube substracted
</span><span>            </span><span style="color:#65737e;"># 3*9 - 1 = 26 sub cubes(except the most middle cube)
</span><span>            sub_cubes.</span><span style="color:#bf616a;">append</span><span>((x[</span><span style="color:#d08770;">0</span><span>], x[</span><span style="color:#d08770;">1</span><span>], y[</span><span style="color:#d08770;">0</span><span>], y[</span><span style="color:#d08770;">1</span><span>], z[</span><span style="color:#d08770;">0</span><span>], z[</span><span style="color:#d08770;">1</span><span>]))
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>sub_cubes
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">count_dots</span><span>(</span><span style="color:#bf616a;">cube</span><span>):
</span><span>    x_min, x_max, y_min, y_max, z_min, z_max = cube
</span><span>    </span><span style="color:#b48ead;">return </span><span>(x_max - x_min + </span><span style="color:#d08770;">1</span><span>) * (y_max - y_min + </span><span style="color:#d08770;">1</span><span>) * (z_max - z_min + </span><span style="color:#d08770;">1</span><span>)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day22_2</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    light_cubes = []
</span><span>    </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span>data:
</span><span>        action, *cube = line
</span><span>        new_cubes = []
</span><span>        </span><span style="color:#b48ead;">for </span><span>cube_light </span><span style="color:#b48ead;">in </span><span>light_cubes:
</span><span>            new_cubes += </span><span style="color:#bf616a;">get_diff_cubes</span><span>(cube_light, cube)
</span><span>        light_cubes = new_cubes[:]
</span><span>        </span><span style="color:#b48ead;">if </span><span>action == &#39;</span><span style="color:#a3be8c;">on</span><span>&#39;:
</span><span>            light_cubes.</span><span style="color:#bf616a;">append</span><span>(cube)
</span><span>    </span><span style="color:#b48ead;">return </span><span style="color:#96b5b4;">sum</span><span>(</span><span style="color:#bf616a;">count_dots</span><span>(cube) </span><span style="color:#b48ead;">for </span><span>cube </span><span style="color:#b48ead;">in </span><span>light_cubes)
</span></code></pre>
<h2 id="day-23-amphipod"><a href="https://adventofcode.com/2021/day/23">Day 23: Amphipod</a></h2>
<p>You get a 2D map(# represents a wall, . represents an open space) of the area(below is an example). Moving each ABCD need different evergy.</p>
<p>Part1: Your task is to find the least energy for move everyone to it's room(ABCD as blow).</p>
<pre data-lang="Text" style="background-color:#2b303b;color:#c0c5ce;" class="language-Text "><code class="language-Text" data-lang="Text"><span>#############
</span><span>#...........#
</span><span>###B#C#B#D###
</span><span>  #A#D#C#A#
</span><span>  #########
</span></code></pre>
<p>Part2: The actual map is folded, a two line to the map(blow is an example). And find the least energy for move everyone to it's room.</p>
<pre data-lang="Text" style="background-color:#2b303b;color:#c0c5ce;" class="language-Text "><code class="language-Text" data-lang="Text"><span>#############
</span><span>#...........#
</span><span>###B#C#B#D###
</span><span>  #D#C#B#A#
</span><span>  #D#B#A#C#
</span><span>  #A#D#C#A#
</span><span>  #########
</span></code></pre>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_data</span><span>():
</span><span>    data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">23</span><span>)
</span><span>    state = []
</span><span>    state.</span><span style="color:#bf616a;">append</span><span>(data[</span><span style="color:#d08770;">1</span><span>][</span><span style="color:#d08770;">1</span><span>])
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">6</span><span>):
</span><span>        state.</span><span style="color:#bf616a;">append</span><span>(data[</span><span style="color:#d08770;">1</span><span>][</span><span style="color:#d08770;">2 </span><span>* loc])
</span><span>    state.</span><span style="color:#bf616a;">append</span><span>(data[</span><span style="color:#d08770;">1</span><span>][</span><span style="color:#d08770;">11</span><span>])
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">4</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">4</span><span>):
</span><span>            state.</span><span style="color:#bf616a;">append</span><span>(data[line+</span><span style="color:#d08770;">2</span><span>][</span><span style="color:#d08770;">3</span><span>+row*</span><span style="color:#d08770;">2</span><span>])
</span><span>    </span><span style="color:#b48ead;">return </span><span>state
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">display</span><span>(</span><span style="color:#bf616a;">state</span><span>):
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">#############</span><span>&#39;)
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&quot;</span><span style="color:#a3be8c;">#</span><span>&quot; + state[</span><span style="color:#d08770;">0</span><span>] + &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;.</span><span style="color:#bf616a;">join</span><span>(state[</span><span style="color:#d08770;">1</span><span>:</span><span style="color:#d08770;">6</span><span>]) + state[</span><span style="color:#d08770;">6</span><span>] + &quot;</span><span style="color:#a3be8c;">#</span><span>&quot;)
</span><span>    </span><span style="color:#b48ead;">for </span><span>line </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">2</span><span>):
</span><span>        t = &quot;</span><span style="color:#a3be8c;">###</span><span>&quot;
</span><span>        </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">4</span><span>):
</span><span>            t += state[</span><span style="color:#d08770;">7 </span><span>+ row + line] + &#39;</span><span style="color:#a3be8c;">#</span><span>&#39;
</span><span>        t += &#39;</span><span style="color:#a3be8c;">##</span><span>&#39;
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(t)
</span><span>    </span><span style="color:#96b5b4;">print</span><span>(&#39;</span><span style="color:#a3be8c;">#############</span><span>&#39;)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_state</span><span>(</span><span style="color:#bf616a;">s</span><span>, </span><span style="color:#bf616a;">a</span><span>, </span><span style="color:#bf616a;">b</span><span>):
</span><span>    </span><span style="color:#b48ead;">return </span><span>s[:a] + s[b] + s[a+</span><span style="color:#d08770;">1</span><span>:b] + s[a] + s[b+</span><span style="color:#d08770;">1</span><span>:]
</span><span>
</span><span>
</span><span>Homes = {&#39;</span><span style="color:#a3be8c;">A</span><span>&#39;: </span><span style="color:#d08770;">0</span><span>, &#39;</span><span style="color:#a3be8c;">B</span><span>&#39;: </span><span style="color:#d08770;">1</span><span>, &#39;</span><span style="color:#a3be8c;">C</span><span>&#39;: </span><span style="color:#d08770;">2</span><span>, &#39;</span><span style="color:#a3be8c;">D</span><span>&#39;: </span><span style="color:#d08770;">3</span><span>}
</span><span>Costs = {&#39;</span><span style="color:#a3be8c;">A</span><span>&#39;: </span><span style="color:#d08770;">1</span><span>, &#39;</span><span style="color:#a3be8c;">B</span><span>&#39;: </span><span style="color:#d08770;">10</span><span>, &#39;</span><span style="color:#a3be8c;">C</span><span>&#39;: </span><span style="color:#d08770;">100</span><span>, &#39;</span><span style="color:#a3be8c;">D</span><span>&#39;: </span><span style="color:#d08770;">1000</span><span>}
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">move_home</span><span>(</span><span style="color:#bf616a;">s</span><span>, </span><span style="color:#bf616a;">cost</span><span>):
</span><span>    </span><span style="color:#b48ead;">global </span><span>Homes
</span><span>    </span><span style="color:#b48ead;">global </span><span>Costs
</span><span>    </span><span style="color:#b48ead;">for </span><span>hp </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">7</span><span>):
</span><span>        </span><span style="color:#b48ead;">if </span><span>s[hp] == &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        i = hp
</span><span>        a = s[i]
</span><span>        r = Homes[a]
</span><span>        ofs = </span><span style="color:#d08770;">7 </span><span>+ r*</span><span style="color:#d08770;">4
</span><span>        line = </span><span style="color:#d08770;">3
</span><span>        </span><span style="color:#b48ead;">while </span><span>line &gt; </span><span style="color:#d08770;">0 </span><span>and s[ofs+line] == a:
</span><span>            line -= </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#b48ead;">if </span><span>s[ofs+line] != &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        cb = (</span><span style="color:#d08770;">2</span><span>+line)*Costs[a]
</span><span>        </span><span style="color:#65737e;"># go right
</span><span>        </span><span style="color:#b48ead;">while </span><span>i &lt; r + </span><span style="color:#d08770;">1 </span><span>and s[i+</span><span style="color:#d08770;">1</span><span>] == &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            cb += Costs[a]*</span><span style="color:#d08770;">2 </span><span style="color:#b48ead;">if </span><span>i &gt; </span><span style="color:#d08770;">0 </span><span style="color:#b48ead;">else </span><span>Costs[a]
</span><span>            i += </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#65737e;"># go left
</span><span>        </span><span style="color:#b48ead;">while </span><span>i &gt; r + </span><span style="color:#d08770;">2 </span><span>and s[i-</span><span style="color:#d08770;">1</span><span>] == &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            cb += Costs[a]*</span><span style="color:#d08770;">2 </span><span style="color:#b48ead;">if </span><span>i &lt; </span><span style="color:#d08770;">6 </span><span style="color:#b48ead;">else </span><span>Costs[a]
</span><span>            i -= </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#b48ead;">if </span><span>i != r + </span><span style="color:#d08770;">1 </span><span>and i != r + </span><span style="color:#d08770;">2</span><span>:
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        </span><span style="color:#b48ead;">return </span><span style="color:#bf616a;">move_home</span><span>(</span><span style="color:#bf616a;">gen_state</span><span>(s, hp, ofs+line), cost + cb)
</span><span>    </span><span style="color:#b48ead;">return </span><span>(s, cost)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">move_out</span><span>(</span><span style="color:#bf616a;">s</span><span>):
</span><span>    </span><span style="color:#b48ead;">global </span><span>Homes
</span><span>    </span><span style="color:#b48ead;">global </span><span>Costs
</span><span>    </span><span style="color:#65737e;"># First move everybody in, if possible
</span><span>    valid = []
</span><span>    </span><span style="color:#65737e;"># Then try to get out, if possible
</span><span>    </span><span style="color:#b48ead;">for </span><span>row </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">4</span><span>):
</span><span>        ofs = </span><span style="color:#d08770;">7 </span><span>+ row*</span><span style="color:#d08770;">4
</span><span>        line = </span><span style="color:#d08770;">0
</span><span>        </span><span style="color:#b48ead;">while </span><span>line &lt; </span><span style="color:#d08770;">4 </span><span>and s[ofs+line] == &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            line += </span><span style="color:#d08770;">1
</span><span>        </span><span style="color:#b48ead;">if </span><span>line == </span><span style="color:#d08770;">4</span><span>:
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        a = s[ofs+line]
</span><span>        </span><span style="color:#b48ead;">if </span><span>(row == Homes[a] and
</span><span>           (line == </span><span style="color:#d08770;">3 </span><span>or
</span><span>           </span><span style="color:#96b5b4;">all</span><span>(s[i] == a </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(ofs + line + </span><span style="color:#d08770;">1</span><span>, ofs+</span><span style="color:#d08770;">4</span><span>)))):
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        rr = row + </span><span style="color:#d08770;">2
</span><span>        cb = Costs[a]*line
</span><span>        </span><span style="color:#b48ead;">while </span><span>rr &lt; </span><span style="color:#d08770;">7 </span><span>and s[rr] == &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            cb += </span><span style="color:#d08770;">2</span><span>*Costs[a] </span><span style="color:#b48ead;">if </span><span>rr &lt; </span><span style="color:#d08770;">6 </span><span style="color:#b48ead;">else </span><span>Costs[a]
</span><span>            valid.</span><span style="color:#bf616a;">append</span><span>(</span><span style="color:#bf616a;">move_home</span><span>(</span><span style="color:#bf616a;">gen_state</span><span>(s, rr, ofs+line), cb))
</span><span>            rr += </span><span style="color:#d08770;">1
</span><span>        ll = row + </span><span style="color:#d08770;">1
</span><span>        cb = Costs[a]*line
</span><span>        </span><span style="color:#b48ead;">while </span><span>ll &gt;= </span><span style="color:#d08770;">0 </span><span>and s[ll] == &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            cb += </span><span style="color:#d08770;">2</span><span>*Costs[a] </span><span style="color:#b48ead;">if </span><span>ll &gt; </span><span style="color:#d08770;">0 </span><span style="color:#b48ead;">else </span><span>Costs[a]
</span><span>            valid.</span><span style="color:#bf616a;">append</span><span>(</span><span style="color:#bf616a;">move_home</span><span>(</span><span style="color:#bf616a;">gen_state</span><span>(s, ll, ofs+line), cb))
</span><span>            ll -= </span><span style="color:#d08770;">1
</span><span>    </span><span style="color:#b48ead;">return </span><span>valid
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">search</span><span>(</span><span style="color:#bf616a;">start</span><span>):
</span><span>    queue = []
</span><span>    </span><span style="color:#b48ead;">for </span><span style="color:#bf616a;">_ </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">100000</span><span>):
</span><span>        queue.</span><span style="color:#bf616a;">append</span><span>([])
</span><span>    queue[</span><span style="color:#d08770;">0</span><span>].</span><span style="color:#bf616a;">append</span><span>(start)
</span><span>    previous = {start: </span><span style="color:#d08770;">None</span><span>}
</span><span>    mind = {start: </span><span style="color:#d08770;">0</span><span>}
</span><span>    </span><span style="color:#b48ead;">for </span><span>cost </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">50000</span><span>):
</span><span>        </span><span style="color:#b48ead;">for </span><span>state </span><span style="color:#b48ead;">in </span><span>queue[cost]:
</span><span>            </span><span style="color:#b48ead;">if </span><span>mind[state] &lt; cost:
</span><span>                </span><span style="color:#b48ead;">continue
</span><span>            valid = </span><span style="color:#bf616a;">move_out</span><span>(state)
</span><span>            </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">all</span><span>(state[i] == &quot;</span><span style="color:#a3be8c;">.</span><span>&quot; </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">7</span><span>)) and </span><span style="color:#96b5b4;">len</span><span>(valid) == </span><span style="color:#d08770;">0</span><span>:
</span><span>                paths = []
</span><span>                </span><span style="color:#b48ead;">while </span><span>state:
</span><span>                    paths.</span><span style="color:#bf616a;">append</span><span>(state)
</span><span>                    state = previous[state]
</span><span>                </span><span style="color:#b48ead;">return </span><span>cost, paths
</span><span>            </span><span style="color:#b48ead;">for </span><span>(nstate, ncost) </span><span style="color:#b48ead;">in </span><span>valid:
</span><span>                </span><span style="color:#b48ead;">if </span><span>nstate in mind and mind[nstate] &lt;= cost+ncost:
</span><span>                    </span><span style="color:#b48ead;">continue
</span><span>                previous[nstate] = state
</span><span>                mind[nstate] = cost + ncost
</span><span>                queue[cost + ncost].</span><span style="color:#bf616a;">append</span><span>(nstate)
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">solver</span><span>(</span><span style="color:#bf616a;">data</span><span>):
</span><span>    cost, </span><span style="color:#bf616a;">_ </span><span>= </span><span style="color:#bf616a;">search</span><span>(&#39;&#39;.</span><span style="color:#bf616a;">join</span><span>(data))
</span><span>    </span><span style="color:#b48ead;">return </span><span>cost
</span></code></pre>
<p>A Dijkstra search with greedy heuristic. I didn't solve this with my own. The code is referenced from <a href="https://github.com/p88h/aoc2021/blob/main/other/day23.py">here</a>. My origin approach is too complicated to apply a Dijkstra search.</p>
<p>It's still fun to play to understand how clever other people's solution is.</p>
<h2 id="day-24-arithmetic-logic-unit"><a href="https://adventofcode.com/2021/day/24">Day 24: Arithmetic Logic Unit</a></h2>
<p>You are going to build a new kind of computer. With blow rule:</p>
<ul>
<li>inp a - Read an input value and write it to variable a.</li>
<li>add a b - Add the value of a to the value of b, then store the result in variable a.</li>
<li>mul a b - Multiply the value of a by the value of b, then store the result in variable a.</li>
<li>div a b - Divide the value of a by the value of b, truncate the result to an integer, then store the result in variable a. (Here, "truncate" means to round the value toward zero.)</li>
<li>mod a b - Divide the value of a by the value of b, then store the remainder in variable a. (This is also called the modulo operation.)</li>
<li>eql a b - If the value of a and b are equal, then store the value 1 in variable a. Otherwise, store the value 0 in variable a.</li>
<li>submarine model numbers are always fourteen-digit numbers consisting only of digits 1 through 9.</li>
<li>after MONAD has finished running all of its instructions, it will indicate that the model number was valid by leaving a 0 in variable z. However, if the model number was invalid, it will leave some other non-zero value in z</li>
</ul>
<p>Part1: What is the largest model number accepted by MONAD?</p>
<p>Part2: What is the smallest model number accepted by MONAD?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">import </span><span>z3
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">solve</span><span>(</span><span style="color:#bf616a;">program</span><span>):
</span><span>    solver = z3.</span><span style="color:#bf616a;">Optimize</span><span>()
</span><span>    digits = [z3.</span><span style="color:#bf616a;">BitVec</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;</span><span style="color:#a3be8c;">d_</span><span>{i}&#39;, </span><span style="color:#d08770;">64</span><span>) </span><span style="color:#b48ead;">for </span><span>i </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">range</span><span>(</span><span style="color:#d08770;">14</span><span>)]
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>d </span><span style="color:#b48ead;">in </span><span>digits:
</span><span>        solver.</span><span style="color:#bf616a;">add</span><span>(d &gt;= </span><span style="color:#d08770;">1</span><span>)
</span><span>        solver.</span><span style="color:#bf616a;">add</span><span>(d &lt;= </span><span style="color:#d08770;">9</span><span>)
</span><span>        digit_input = </span><span style="color:#96b5b4;">iter</span><span>(digits)
</span><span>
</span><span>    zero, one = z3.</span><span style="color:#bf616a;">BitVecVal</span><span>(</span><span style="color:#d08770;">0</span><span>, </span><span style="color:#d08770;">64</span><span>), z3.</span><span style="color:#bf616a;">BitVecVal</span><span>(</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">64</span><span>)
</span><span>    registers = {r: zero </span><span style="color:#b48ead;">for </span><span>r </span><span style="color:#b48ead;">in </span><span>&#39;</span><span style="color:#a3be8c;">wxyz</span><span>&#39;}
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>i, line </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(program):
</span><span>        </span><span style="color:#96b5b4;">vars </span><span>= line.</span><span style="color:#bf616a;">split</span><span>()
</span><span>        </span><span style="color:#b48ead;">if </span><span>&#39;</span><span style="color:#a3be8c;">inp</span><span>&#39; in line:
</span><span>            registers[</span><span style="color:#96b5b4;">vars</span><span>[-</span><span style="color:#d08770;">1</span><span>]] = </span><span style="color:#96b5b4;">next</span><span>(digit_input)
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        operator, a, b = </span><span style="color:#96b5b4;">vars
</span><span>        b = registers[b] </span><span style="color:#b48ead;">if </span><span>b in registers </span><span style="color:#b48ead;">else </span><span style="color:#bf616a;">int</span><span>(b)
</span><span>        c = z3.</span><span style="color:#bf616a;">BitVec</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;</span><span style="color:#a3be8c;">v</span><span>{i}&#39;, </span><span style="color:#d08770;">64</span><span>)
</span><span>        </span><span style="color:#b48ead;">if </span><span>operator == &#39;</span><span style="color:#a3be8c;">add</span><span>&#39;:
</span><span>            solver.</span><span style="color:#bf616a;">add</span><span>(c == registers[a] + b)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>operator == &#39;</span><span style="color:#a3be8c;">mul</span><span>&#39;:
</span><span>            solver.</span><span style="color:#bf616a;">add</span><span>(c == registers[a] * b)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>operator == &#39;</span><span style="color:#a3be8c;">mod</span><span>&#39;:
</span><span>            solver.</span><span style="color:#bf616a;">add</span><span>(registers[a] &gt;= </span><span style="color:#d08770;">0</span><span>)
</span><span>            solver.</span><span style="color:#bf616a;">add</span><span>(b &gt; </span><span style="color:#d08770;">0</span><span>)
</span><span>            solver.</span><span style="color:#bf616a;">add</span><span>(c == registers[a] % b)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>operator == &#39;</span><span style="color:#a3be8c;">div</span><span>&#39;:
</span><span>            solver.</span><span style="color:#bf616a;">add</span><span>(b != </span><span style="color:#d08770;">0</span><span>)
</span><span>            solver.</span><span style="color:#bf616a;">add</span><span>(c == registers[a] / b)
</span><span>        </span><span style="color:#b48ead;">elif </span><span>operator == &#39;</span><span style="color:#a3be8c;">eql</span><span>&#39;:
</span><span>            solver.</span><span style="color:#bf616a;">add</span><span>(c == z3.</span><span style="color:#bf616a;">If</span><span>(registers[a] == b, one, zero))
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            </span><span style="color:#b48ead;">raise </span><span style="color:#bf616a;">ValueError</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;</span><span style="color:#a3be8c;">Unknown operator: </span><span>{operator}&#39;)
</span><span>        registers[a] = c
</span><span>
</span><span>    solver.</span><span style="color:#bf616a;">add</span><span>(registers[&#39;</span><span style="color:#a3be8c;">z</span><span>&#39;] == </span><span style="color:#d08770;">0</span><span>)
</span><span>
</span><span>    </span><span style="color:#b48ead;">for </span><span>func </span><span style="color:#b48ead;">in </span><span>(solver.maximize, solver.minimize):
</span><span>        solver.</span><span style="color:#bf616a;">push</span><span>()
</span><span>        </span><span style="color:#bf616a;">func</span><span>(</span><span style="color:#96b5b4;">sum</span><span>((</span><span style="color:#d08770;">10 </span><span>** i) * d </span><span style="color:#b48ead;">for </span><span>i, d </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(digits[::-</span><span style="color:#d08770;">1</span><span>])))
</span><span>        solver.</span><span style="color:#bf616a;">check</span><span>()
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(</span><span style="color:#b48ead;">f</span><span>&#39;{func.__name__}&#39;)
</span><span>        m = solver.</span><span style="color:#bf616a;">model</span><span>()
</span><span>        </span><span style="color:#96b5b4;">print</span><span>(&#39;&#39;.</span><span style="color:#bf616a;">join</span><span>([</span><span style="color:#bf616a;">str</span><span>(m[d]) </span><span style="color:#b48ead;">for </span><span>d </span><span style="color:#b48ead;">in </span><span>digits]))
</span><span>        solver.</span><span style="color:#bf616a;">pop</span><span>()
</span></code></pre>
<p>I havn't heard of Z3. The solution is from <a href="https://www.reddit.com/r/adventofcode/comments/rnejv5/2021_day_24_solutions/">reddit</a>.</p>
<p>There is another approach is to analysis the input sequence(which will have special case to solve this problem because of the simularity of each-14 part). But I still like the Z3 approach, which is more elegant and generic.</p>
<h2 id="day-25-sea-cucumber"><a href="https://adventofcode.com/2021/day/25">Day 25: Sea Cucumber</a></h2>
<ul>
<li>you got a 2D map of the area(. represent emply, &gt; represent east-facing creature and V represent south-facing creature, example as blow).</li>
<li>At each step, east-facing creature will move forward one step if the next-east is empty, south-facing creature will move down one step if the next-south is empty.</li>
<li>sea cucumbers that move off the right edge of the map appear on the left edge, and sea cucumbers that move off the bottom edge of the map appear on the top edge.</li>
</ul>
<pre data-lang="Text" style="background-color:#2b303b;color:#c0c5ce;" class="language-Text "><code class="language-Text" data-lang="Text"><span>v...&gt;&gt;.vv&gt;
</span><span>.vv&gt;&gt;.vv..
</span><span>&gt;&gt;.&gt;v&gt;...v
</span><span>&gt;&gt;v&gt;&gt;.&gt;.v.
</span><span>v&gt;v.vv.v..
</span><span>&gt;.&gt;&gt;..v...
</span><span>.vv..&gt;.&gt;v.
</span><span>v.v..&gt;&gt;v.v
</span><span>....v..v.&gt;
</span></code></pre>
<p>Question: To find a safe place to land your submarine, the sea cucumbers need to stop moving. How many steps does it take for the sea cucumbers to stop moving?</p>
<pre data-lang="Python" style="background-color:#2b303b;color:#c0c5ce;" class="language-Python "><code class="language-Python" data-lang="Python"><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">gen_data</span><span>():
</span><span>    data = </span><span style="color:#bf616a;">parse_data</span><span>(</span><span style="color:#bf616a;">day</span><span>=</span><span style="color:#d08770;">25</span><span>, </span><span style="color:#bf616a;">parser</span><span>=str)
</span><span>    system = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>y, line </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(data):
</span><span>        </span><span style="color:#b48ead;">for </span><span>x, c </span><span style="color:#b48ead;">in </span><span style="color:#96b5b4;">enumerate</span><span>(line):
</span><span>            system[(x, y)] = c
</span><span>    </span><span style="color:#b48ead;">return </span><span>system
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">move_once</span><span>(</span><span style="color:#bf616a;">system</span><span>):
</span><span>    new_system = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    x_max, y_max = </span><span style="color:#96b5b4;">max</span><span>(system)
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc, symbol </span><span style="color:#b48ead;">in </span><span>system.</span><span style="color:#bf616a;">items</span><span>():
</span><span>        </span><span style="color:#65737e;"># move east-facing
</span><span>        </span><span style="color:#b48ead;">if </span><span>loc in new_system:
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        x, y = loc
</span><span>        next_right_loc = (x + </span><span style="color:#d08770;">1</span><span>, y) </span><span style="color:#b48ead;">if </span><span>x &lt; x_max </span><span style="color:#b48ead;">else </span><span>(</span><span style="color:#d08770;">0</span><span>, y)
</span><span>        </span><span style="color:#b48ead;">if </span><span>symbol == &#39;</span><span style="color:#a3be8c;">&gt;</span><span>&#39; and system[next_right_loc] == &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            new_system[next_right_loc] = &#39;</span><span style="color:#a3be8c;">&gt;</span><span>&#39;
</span><span>            new_system[loc] = &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            new_system[loc] = symbol
</span><span>
</span><span>    final_system = </span><span style="color:#bf616a;">defaultdict</span><span>()
</span><span>    </span><span style="color:#b48ead;">for </span><span>loc, symbol </span><span style="color:#b48ead;">in </span><span>new_system.</span><span style="color:#bf616a;">items</span><span>():
</span><span>        </span><span style="color:#65737e;"># move south-facing
</span><span>        </span><span style="color:#b48ead;">if </span><span>loc in final_system:
</span><span>            </span><span style="color:#b48ead;">continue
</span><span>        x, y = loc
</span><span>        next_down_loc = (x, y + </span><span style="color:#d08770;">1</span><span>) </span><span style="color:#b48ead;">if </span><span>y &lt; y_max </span><span style="color:#b48ead;">else </span><span>(x, </span><span style="color:#d08770;">0</span><span>)
</span><span>        </span><span style="color:#b48ead;">if </span><span>symbol == &#39;</span><span style="color:#a3be8c;">v</span><span>&#39; and new_system[next_down_loc] == &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;:
</span><span>            final_system[next_down_loc] = &#39;</span><span style="color:#a3be8c;">v</span><span>&#39;
</span><span>            final_system[loc] = &#39;</span><span style="color:#a3be8c;">.</span><span>&#39;
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            final_system[loc] = symbol
</span><span>
</span><span>    </span><span style="color:#b48ead;">return </span><span>final_system
</span><span>
</span><span>
</span><span style="color:#b48ead;">def </span><span style="color:#8fa1b3;">day25</span><span>(</span><span style="color:#bf616a;">system</span><span>):
</span><span>    num = </span><span style="color:#d08770;">0
</span><span>    </span><span style="color:#b48ead;">while </span><span style="color:#d08770;">True</span><span>:
</span><span>        num += </span><span style="color:#d08770;">1
</span><span>        new_system = </span><span style="color:#bf616a;">move_once</span><span>(system)
</span><span>        </span><span style="color:#b48ead;">if </span><span style="color:#96b5b4;">all</span><span>(new_system[loc] == symbol </span><span style="color:#b48ead;">for </span><span>loc, symbol </span><span style="color:#b48ead;">in </span><span>system.</span><span style="color:#bf616a;">items</span><span>()):
</span><span>            </span><span style="color:#b48ead;">return </span><span>num
</span><span>        </span><span style="color:#b48ead;">else</span><span>:
</span><span>            system = new_system
</span></code></pre>
<p>A kind of simple simulation.</p>
<h2 id="conclusion">Conclusion</h2>
<p>At last, this year of adventofcode come to the end. Although some of the problems are too hard, I can't solve it on my own, but it's still a lot of fun to follow the clear thought and solution shared through reddit, github and youtube, from which I have learned so many things.</p>
<p>Thank you Eric the authors of the advent of code, the community and people who share their thought and solution.</p>

    </div>

    
    

    <div class="post-footer">
        
            
                <div class="post-tags">
                    
                        <a href="https://blog.xiongdong57.top/tags/python/">#Python</a>
                    
                </div>
            
            
                <div class="post-nav">
                    
                        <a class="previous" href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;linux-server&#x2F;"> Oracle Cloud Linux Server Configuration</a>
                    
                    
                        <a class="next" href="https:&#x2F;&#x2F;blog.xiongdong57.top&#x2F;process-analysis&#x2F;">Process Analysis </a>
                    
                </div>
            

        

    </div>

    
    
</article>


                </div>
            </main>

            
            
        </div>

      
          <script type="text/javascript" src="https://blog.xiongdong57.top/even.js" ></script>
      
    </body>

</html>
